{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Governing Equations of Projectile Motion We start from Newton\u2019s Second Law for a projectile launched in a uniform gravitational field (ignoring air resistance): \\[ \\mathbf{F} = m \\mathbf{a} \\] For a projectile of mass \\(m\\) : Horizontal direction ( \\(x\\) ): no acceleration (neglecting air resistance), so \\[ a_x = 0 \\implies \\frac{d^2 x}{dt^2} = 0 \\] Vertical direction ( \\(y\\) ): \\[ a_y = -g \\implies \\frac{d^2 y}{dt^2} = -g \\] Initial Conditions At \\(t = 0\\) : \\[ x(0) = 0, \\quad y(0) = h \\] \\[ v_x(0) = v_0 \\cos \\theta, \\quad v_y(0) = v_0 \\sin \\theta \\] where \\(v_0\\) is the initial speed, \\(\\theta\\) is the angle of projection, \\(h\\) is the initial height, \\(g\\) is gravitational acceleration. Solutions to the Equations Solving the second order ODEs: Horizontal motion: \\[ x(t) = v_0 \\cos \\theta \\cdot t \\] Vertical motion: \\[ y(t) = h + v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 \\] Time of Flight The time when projectile hits the ground ( \\(y=0\\) ): \\[ 0 = h + v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 \\] Solve quadratic in \\(t\\) : \\[ t = \\frac{v_0 \\sin \\theta + \\sqrt{(v_0 \\sin \\theta)^2 + 2 g h}}{g} \\] (Only the positive root is physically meaningful.) Horizontal Range Using \\(t\\) above, range \\(R\\) is \\[ R(\\theta) = x(t) = v_0 \\cos \\theta \\times t \\] This expression defines a family of solutions parametrized by \\(\\theta\\) , \\(v_0\\) , \\(h\\) , and \\(g\\) . 2. Analysis of the Range The range depends on the angle \\(\\theta\\) via \\(\\sin\\theta\\) and \\(\\cos\\theta\\) . For \\(h=0\\) , the well-known formula reduces to \\[ R = \\frac{v_0^2}{g} \\sin 2\\theta \\] which peaks at \\(\\theta = 45^\\circ\\) . When \\(h \\neq 0\\) , the maximum range angle shifts. Changes in \\(v_0\\) scale the range proportionally. Increasing \\(g\\) reduces the range. 3. Practical Applications Uneven terrain : Can model \\(h\\neq 0\\) . Air resistance : Requires adding drag force, typically non-linear; analytical solutions become complicated, often requiring numerical simulation. Wind : Adds horizontal acceleration component. Sports and Engineering : Ballistics, sports (soccer, basketball), launch vehicles, fireworks. 4. Implementation: Python Simulation & Visualization import numpy as np import matplotlib.pyplot as plt def time_of_flight(v0, theta, h, g=9.81): \"\"\" Calculate time of flight until projectile hits ground y=0. Parameters: v0: initial speed (m/s) theta: launch angle in radians h: initial height (m) g: gravitational acceleration (m/s^2) Returns: time_of_flight (float) \"\"\" term1 = v0 * np.sin(theta) discriminant = term1**2 + 2 * g * h t_flight = (term1 + np.sqrt(discriminant)) / g return t_flight def range_projectile(v0, theta, h, g=9.81): \"\"\" Calculate horizontal range of projectile. Parameters: v0: initial speed (m/s) theta: launch angle in radians h: initial height (m) g: gravitational acceleration (m/s^2) Returns: horizontal range (float) \"\"\" t_flight = time_of_flight(v0, theta, h, g) return v0 * np.cos(theta) * t_flight # Parameters v0 = 20 # m/s h = 0 # initial height in meters g = 9.81 # m/s^2 angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) ranges = np.array([range_projectile(v0, angle, h, g) for angle in angles_rad]) # Plot plt.figure(figsize=(10,6)) plt.plot(angles_deg, ranges) plt.title(\"Projectile Range vs Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.show() Exploring Parameters You can vary \\(v_0\\) , \\(h\\) , and \\(g\\) and plot multiple curves on the same graph: h_values = [0, 5, 10] # Different launch heights plt.figure(figsize=(10,6)) for h_i in h_values: ranges = np.array([range_projectile(v0, angle, h_i, g) for angle in angles_rad]) plt.plot(angles_deg, ranges, label=f'h = {h_i} m') plt.title(\"Projectile Range vs Launch Angle for Different Launch Heights\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid(True) plt.show() 5. Discussion on Limitations and Extensions Limitations of the Idealized Model: Ignores air resistance which can significantly reduce range and alter optimal angle. Assumes uniform gravitational field. Assumes flat ground at final landing spot (can be adapted for uneven terrain but complex). Possible Extensions: Air Drag: Model drag force \\(\\mathbf{F}_d = -\\frac{1}{2} C_d \\rho A v^2 \\hat{v}\\) , numerical integration required. Wind Effects: Add horizontal wind velocity component. Variable Gravity: For long-range trajectories (e.g., missiles, rockets), gravity changes with altitude. Spin & Magnus Effect: For sports balls. Summary Derived general projectile motion equations from first principles. Obtained formula for range as function of launch angle, initial velocity, initial height, and gravity. Demonstrated Python simulation with visualizations. Discussed real-world applicability and model limitations.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations-of-projectile-motion","text":"We start from Newton\u2019s Second Law for a projectile launched in a uniform gravitational field (ignoring air resistance): \\[ \\mathbf{F} = m \\mathbf{a} \\] For a projectile of mass \\(m\\) : Horizontal direction ( \\(x\\) ): no acceleration (neglecting air resistance), so \\[ a_x = 0 \\implies \\frac{d^2 x}{dt^2} = 0 \\] Vertical direction ( \\(y\\) ): \\[ a_y = -g \\implies \\frac{d^2 y}{dt^2} = -g \\]","title":"Governing Equations of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#initial-conditions","text":"At \\(t = 0\\) : \\[ x(0) = 0, \\quad y(0) = h \\] \\[ v_x(0) = v_0 \\cos \\theta, \\quad v_y(0) = v_0 \\sin \\theta \\] where \\(v_0\\) is the initial speed, \\(\\theta\\) is the angle of projection, \\(h\\) is the initial height, \\(g\\) is gravitational acceleration.","title":"Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solutions-to-the-equations","text":"Solving the second order ODEs: Horizontal motion: \\[ x(t) = v_0 \\cos \\theta \\cdot t \\] Vertical motion: \\[ y(t) = h + v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 \\]","title":"Solutions to the Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The time when projectile hits the ground ( \\(y=0\\) ): \\[ 0 = h + v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 \\] Solve quadratic in \\(t\\) : \\[ t = \\frac{v_0 \\sin \\theta + \\sqrt{(v_0 \\sin \\theta)^2 + 2 g h}}{g} \\] (Only the positive root is physically meaningful.)","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-range","text":"Using \\(t\\) above, range \\(R\\) is \\[ R(\\theta) = x(t) = v_0 \\cos \\theta \\times t \\] This expression defines a family of solutions parametrized by \\(\\theta\\) , \\(v_0\\) , \\(h\\) , and \\(g\\) .","title":"Horizontal Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range depends on the angle \\(\\theta\\) via \\(\\sin\\theta\\) and \\(\\cos\\theta\\) . For \\(h=0\\) , the well-known formula reduces to \\[ R = \\frac{v_0^2}{g} \\sin 2\\theta \\] which peaks at \\(\\theta = 45^\\circ\\) . When \\(h \\neq 0\\) , the maximum range angle shifts. Changes in \\(v_0\\) scale the range proportionally. Increasing \\(g\\) reduces the range.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Uneven terrain : Can model \\(h\\neq 0\\) . Air resistance : Requires adding drag force, typically non-linear; analytical solutions become complicated, often requiring numerical simulation. Wind : Adds horizontal acceleration component. Sports and Engineering : Ballistics, sports (soccer, basketball), launch vehicles, fireworks.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-simulation-visualization","text":"import numpy as np import matplotlib.pyplot as plt def time_of_flight(v0, theta, h, g=9.81): \"\"\" Calculate time of flight until projectile hits ground y=0. Parameters: v0: initial speed (m/s) theta: launch angle in radians h: initial height (m) g: gravitational acceleration (m/s^2) Returns: time_of_flight (float) \"\"\" term1 = v0 * np.sin(theta) discriminant = term1**2 + 2 * g * h t_flight = (term1 + np.sqrt(discriminant)) / g return t_flight def range_projectile(v0, theta, h, g=9.81): \"\"\" Calculate horizontal range of projectile. Parameters: v0: initial speed (m/s) theta: launch angle in radians h: initial height (m) g: gravitational acceleration (m/s^2) Returns: horizontal range (float) \"\"\" t_flight = time_of_flight(v0, theta, h, g) return v0 * np.cos(theta) * t_flight # Parameters v0 = 20 # m/s h = 0 # initial height in meters g = 9.81 # m/s^2 angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) ranges = np.array([range_projectile(v0, angle, h, g) for angle in angles_rad]) # Plot plt.figure(figsize=(10,6)) plt.plot(angles_deg, ranges) plt.title(\"Projectile Range vs Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.show()","title":"4. Implementation: Python Simulation &amp; Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#exploring-parameters","text":"You can vary \\(v_0\\) , \\(h\\) , and \\(g\\) and plot multiple curves on the same graph: h_values = [0, 5, 10] # Different launch heights plt.figure(figsize=(10,6)) for h_i in h_values: ranges = np.array([range_projectile(v0, angle, h_i, g) for angle in angles_rad]) plt.plot(angles_deg, ranges, label=f'h = {h_i} m') plt.title(\"Projectile Range vs Launch Angle for Different Launch Heights\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid(True) plt.show()","title":"Exploring Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-discussion-on-limitations-and-extensions","text":"Limitations of the Idealized Model: Ignores air resistance which can significantly reduce range and alter optimal angle. Assumes uniform gravitational field. Assumes flat ground at final landing spot (can be adapted for uneven terrain but complex). Possible Extensions: Air Drag: Model drag force \\(\\mathbf{F}_d = -\\frac{1}{2} C_d \\rho A v^2 \\hat{v}\\) , numerical integration required. Wind Effects: Add horizontal wind velocity component. Variable Gravity: For long-range trajectories (e.g., missiles, rockets), gravity changes with altitude. Spin & Magnus Effect: For sports balls.","title":"5. Discussion on Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary","text":"Derived general projectile motion equations from first principles. Obtained formula for range as function of launch angle, initial velocity, initial height, and gravity. Demonstrated Python simulation with visualizations. Discussed real-world applicability and model limitations.","title":"Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Solution for Problem 2: Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation Differential Equation The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin \\theta = A \\cos(\\omega t) \\] where \\(\\theta(t)\\) : angular displacement, \\(b\\) : damping coefficient, \\(g\\) : acceleration due to gravity, \\(L\\) : length of the pendulum, \\(A\\) : amplitude of external driving torque, \\(\\omega\\) : angular frequency of driving force. Small-Angle Approximation For small oscillations, \\(\\sin \\theta \\approx \\theta\\) . The equation becomes linear: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] Homogeneous Solution (No Driving Force) The characteristic equation: \\[ r^2 + b r + \\frac{g}{L} = 0 \\] Solutions: \\[ r = \\frac{-b \\pm \\sqrt{b^2 - 4 \\frac{g}{L}}}{2} \\] Underdamped ( \\(b^2 < 4g/L\\) ): Oscillatory decay. Overdamped ( \\(b^2 > 4g/L\\) ): Exponential decay without oscillation. Critically damped ( \\(b^2 = 4g/L\\) ). Particular Solution (Steady-State Forced Response) Assuming steady-state solution of form: \\[ \\theta_p = \\Theta \\cos(\\omega t - \\delta) \\] Plug into differential equation and solve for amplitude \\(\\Theta\\) : \\[ \\Theta = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + b^2 \\omega^2}} \\] Phase lag \\(\\delta\\) satisfies: \\[ \\tan \\delta = \\frac{b \\omega}{\\frac{g}{L} - \\omega^2} \\] Resonance Condition Resonance approximately occurs when the driving frequency matches the natural frequency of the system (undamped): \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] The presence of damping \\(b\\) shifts and broadens the resonance peak. 2. Analysis of Dynamics Damping \\(b\\) : Increasing damping reduces amplitude, broadens resonance peak, and suppresses chaos. Driving amplitude \\(A\\) : Larger amplitudes can push the system into nonlinear and chaotic regimes. Driving frequency \\(\\omega\\) : Changes in frequency cause resonance effects; near \\(\\omega_0\\) , amplitude peaks. Nonlinearity ( \\(\\sin \\theta\\) ) : For large \\(\\theta\\) , the system exhibits complex dynamics including period doubling and chaos. 3. Practical Applications Energy Harvesting: Mechanical oscillators capturing ambient vibrations often modeled as forced damped pendulums. Suspension Bridges: Forced oscillations due to wind or traffic forces modeled similarly to study resonance risks. Oscillating Circuits: RLC circuits with external AC sources show analogous behavior. Biomechanics: Human gait analyzed with forced oscillator models. 4. Implementation: Python Simulation We use numerical integration (Runge-Kutta 4th order) to solve the nonlinear ODE. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # m/s^2 L = 1.0 # meters b = 0.5 # damping coefficient A = 1.2 # driving amplitude omega = 2/3 # driving frequency # System of first order ODEs: # Let y = [theta, omega_theta], where omega_theta = dtheta/dt def forced_damped_pendulum(t, y): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -b * omega_theta - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span t_span = (0, 60) t_eval = np.linspace(*t_span, 1000) # Initial conditions: theta=0.2 rad, omega=0 y0 = [0.2, 0.0] # Solve ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot angular displacement over time plt.figure(figsize=(10,4)) plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum: Angular Displacement vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.grid(True) plt.show() # Phase space plot (\u03b8 vs \u03c9) plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[1]) plt.title(\"Phase Space of Forced Damped Pendulum\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular velocity \u03c9 (rad/s)\") plt.grid(True) plt.show() 5. Extending the Analysis: Poincar\u00e9 Section To analyze transitions to chaos, sample the system at driving period intervals \\(T = \\frac{2\\pi}{\\omega}\\) : T = 2 * np.pi / omega poincare_times = np.arange(0, t_span[1], T) # Interpolate solution at Poincare times theta_poincare = np.interp(poincare_times, sol.t, sol.y[0]) omega_poincare = np.interp(poincare_times, sol.t, sol.y[1]) plt.figure(figsize=(6,6)) plt.scatter(theta_poincare, omega_poincare, s=10, color='red') plt.title(\"Poincar\u00e9 Section of Forced Damped Pendulum\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular velocity \u03c9 (rad/s)\") plt.grid(True) plt.show() 6. Discussion on Limitations and Extensions Nonlinearity: Full nonlinear \\(\\sin \\theta\\) model necessary for large oscillations. Numerical Sensitivity: Chaotic regimes require fine resolution and careful numerical methods. Extensions: Introduce nonlinear damping, non-periodic forcing, or coupling multiple pendulums. Physical factors: Air resistance, structural flex, and other real-world factors not included here. Summary Derived and analyzed forced damped pendulum equations. Explored approximate linear solutions and resonance. Created computational models to simulate and visualize behavior. Used phase space and Poincar\u00e9 sections to identify chaotic transitions. Discussed real-world relevance and possible extensions.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solution-for-problem-2-dynamics-of-a-forced-damped-pendulum","text":"","title":"Solution for Problem 2: Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation","text":"The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin \\theta = A \\cos(\\omega t) \\] where \\(\\theta(t)\\) : angular displacement, \\(b\\) : damping coefficient, \\(g\\) : acceleration due to gravity, \\(L\\) : length of the pendulum, \\(A\\) : amplitude of external driving torque, \\(\\omega\\) : angular frequency of driving force.","title":"Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations, \\(\\sin \\theta \\approx \\theta\\) . The equation becomes linear: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\]","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#homogeneous-solution-no-driving-force","text":"The characteristic equation: \\[ r^2 + b r + \\frac{g}{L} = 0 \\] Solutions: \\[ r = \\frac{-b \\pm \\sqrt{b^2 - 4 \\frac{g}{L}}}{2} \\] Underdamped ( \\(b^2 < 4g/L\\) ): Oscillatory decay. Overdamped ( \\(b^2 > 4g/L\\) ): Exponential decay without oscillation. Critically damped ( \\(b^2 = 4g/L\\) ).","title":"Homogeneous Solution (No Driving Force)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#particular-solution-steady-state-forced-response","text":"Assuming steady-state solution of form: \\[ \\theta_p = \\Theta \\cos(\\omega t - \\delta) \\] Plug into differential equation and solve for amplitude \\(\\Theta\\) : \\[ \\Theta = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + b^2 \\omega^2}} \\] Phase lag \\(\\delta\\) satisfies: \\[ \\tan \\delta = \\frac{b \\omega}{\\frac{g}{L} - \\omega^2} \\]","title":"Particular Solution (Steady-State Forced Response)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance approximately occurs when the driving frequency matches the natural frequency of the system (undamped): \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] The presence of damping \\(b\\) shifts and broadens the resonance peak.","title":"Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Damping \\(b\\) : Increasing damping reduces amplitude, broadens resonance peak, and suppresses chaos. Driving amplitude \\(A\\) : Larger amplitudes can push the system into nonlinear and chaotic regimes. Driving frequency \\(\\omega\\) : Changes in frequency cause resonance effects; near \\(\\omega_0\\) , amplitude peaks. Nonlinearity ( \\(\\sin \\theta\\) ) : For large \\(\\theta\\) , the system exhibits complex dynamics including period doubling and chaos.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting: Mechanical oscillators capturing ambient vibrations often modeled as forced damped pendulums. Suspension Bridges: Forced oscillations due to wind or traffic forces modeled similarly to study resonance risks. Oscillating Circuits: RLC circuits with external AC sources show analogous behavior. Biomechanics: Human gait analyzed with forced oscillator models.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"We use numerical integration (Runge-Kutta 4th order) to solve the nonlinear ODE. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # m/s^2 L = 1.0 # meters b = 0.5 # damping coefficient A = 1.2 # driving amplitude omega = 2/3 # driving frequency # System of first order ODEs: # Let y = [theta, omega_theta], where omega_theta = dtheta/dt def forced_damped_pendulum(t, y): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -b * omega_theta - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span t_span = (0, 60) t_eval = np.linspace(*t_span, 1000) # Initial conditions: theta=0.2 rad, omega=0 y0 = [0.2, 0.0] # Solve ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot angular displacement over time plt.figure(figsize=(10,4)) plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum: Angular Displacement vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.grid(True) plt.show() # Phase space plot (\u03b8 vs \u03c9) plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[1]) plt.title(\"Phase Space of Forced Damped Pendulum\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular velocity \u03c9 (rad/s)\") plt.grid(True) plt.show()","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-extending-the-analysis-poincare-section","text":"To analyze transitions to chaos, sample the system at driving period intervals \\(T = \\frac{2\\pi}{\\omega}\\) : T = 2 * np.pi / omega poincare_times = np.arange(0, t_span[1], T) # Interpolate solution at Poincare times theta_poincare = np.interp(poincare_times, sol.t, sol.y[0]) omega_poincare = np.interp(poincare_times, sol.t, sol.y[1]) plt.figure(figsize=(6,6)) plt.scatter(theta_poincare, omega_poincare, s=10, color='red') plt.title(\"Poincar\u00e9 Section of Forced Damped Pendulum\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular velocity \u03c9 (rad/s)\") plt.grid(True) plt.show()","title":"5. Extending the Analysis: Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-discussion-on-limitations-and-extensions","text":"Nonlinearity: Full nonlinear \\(\\sin \\theta\\) model necessary for large oscillations. Numerical Sensitivity: Chaotic regimes require fine resolution and careful numerical methods. Extensions: Introduce nonlinear damping, non-periodic forcing, or coupling multiple pendulums. Physical factors: Air resistance, structural flex, and other real-world factors not included here.","title":"6. Discussion on Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary","text":"Derived and analyzed forced damped pendulum equations. Explored approximate linear solutions and resonance. Created computational models to simulate and visualize behavior. Used phase space and Poincar\u00e9 sections to identify chaotic transitions. Discussed real-world relevance and possible extensions.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Solution: Orbital Period and Orbital Radius (Kepler\u2019s Third Law) 1. Theoretical Derivation For a body of mass \\(m\\) orbiting a much larger mass \\(M\\) (e.g., a planet orbiting the Sun), under Newtonian gravity, the gravitational force provides the centripetal force required for circular motion: \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = m \\frac{v^2}{r} \\] where: \\(G\\) = gravitational constant, \\(r\\) = orbital radius, \\(v\\) = orbital speed. Simplify: \\[ v^2 = \\frac{G M}{r} \\] Orbital period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2 \\pi r}{v} \\] Substitute \\(v\\) : \\[ T = 2 \\pi r \\sqrt{\\frac{r}{G M}} = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\] Square both sides: \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] This is Kepler\u2019s Third Law for circular orbits: the square of the period is proportional to the cube of the radius. 2. Implications in Astronomy Determining Planetary Masses: Given \\(T\\) and \\(r\\) , one can estimate the mass \\(M\\) of the central body. Satellite Orbits: Used to design orbits with desired periods. Distance Measurements: Helps infer distances in planetary and stellar systems. Foundation for Elliptical Orbits: Kepler\u2019s law extends to elliptical orbits with \\(r^3\\) replaced by the cube of the semi-major axis. 3. Real-World Examples Moon-Earth System: \\(r \\approx 3.84 \\times 10^8\\) m, \\(T \\approx 27.3\\) days, Using \\(M_{\\text{Earth}} \\approx 5.97 \\times 10^{24}\\) kg, the formula holds closely. Planets in Solar System: Plotting \\(T^2\\) vs. \\(r^3\\) shows linear relationship confirming the law. 4. Computational Model (Python) import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Orbital radii in meters (Earth, Mars, Jupiter) radii = np.array([1.496e11, 2.279e11, 7.785e11]) # Compute orbital periods using Kepler's law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M_sun)) # Convert periods from seconds to Earth years periods_years = periods / (60 * 60 * 24 * 365.25) # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii**3, periods**2, 'o-', label='Computed data') plt.xlabel('Orbital Radius cubed (m^3)') plt.ylabel('Orbital Period squared (s^2)') plt.title('Verification of Kepler\\'s Third Law') plt.grid(True) plt.legend() plt.show() print(\"Orbital periods (years):\", periods_years) 5. Extensions Elliptical Orbits: Kepler\u2019s Third Law generalizes using semi-major axis \\(a\\) : \\[ T^2 \\propto a^3 \\] Multiple Body Systems: Requires numerical integration for complex gravitational interactions. Relativistic Corrections: For strong gravity (e.g., near black holes). Summary Derived \\(T^2 \\propto r^3\\) for circular orbits. Explained its significance in astronomy and satellite mechanics. Verified using example orbital data. Provided a Python simulation and visualization.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#solution-orbital-period-and-orbital-radius-keplers-third-law","text":"","title":"Solution: Orbital Period and Orbital Radius (Kepler\u2019s Third Law)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"For a body of mass \\(m\\) orbiting a much larger mass \\(M\\) (e.g., a planet orbiting the Sun), under Newtonian gravity, the gravitational force provides the centripetal force required for circular motion: \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = m \\frac{v^2}{r} \\] where: \\(G\\) = gravitational constant, \\(r\\) = orbital radius, \\(v\\) = orbital speed. Simplify: \\[ v^2 = \\frac{G M}{r} \\] Orbital period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2 \\pi r}{v} \\] Substitute \\(v\\) : \\[ T = 2 \\pi r \\sqrt{\\frac{r}{G M}} = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\] Square both sides: \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] This is Kepler\u2019s Third Law for circular orbits: the square of the period is proportional to the cube of the radius.","title":"1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-in-astronomy","text":"Determining Planetary Masses: Given \\(T\\) and \\(r\\) , one can estimate the mass \\(M\\) of the central body. Satellite Orbits: Used to design orbits with desired periods. Distance Measurements: Helps infer distances in planetary and stellar systems. Foundation for Elliptical Orbits: Kepler\u2019s law extends to elliptical orbits with \\(r^3\\) replaced by the cube of the semi-major axis.","title":"2. Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"Moon-Earth System: \\(r \\approx 3.84 \\times 10^8\\) m, \\(T \\approx 27.3\\) days, Using \\(M_{\\text{Earth}} \\approx 5.97 \\times 10^{24}\\) kg, the formula holds closely. Planets in Solar System: Plotting \\(T^2\\) vs. \\(r^3\\) shows linear relationship confirming the law.","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-computational-model-python","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Orbital radii in meters (Earth, Mars, Jupiter) radii = np.array([1.496e11, 2.279e11, 7.785e11]) # Compute orbital periods using Kepler's law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M_sun)) # Convert periods from seconds to Earth years periods_years = periods / (60 * 60 * 24 * 365.25) # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii**3, periods**2, 'o-', label='Computed data') plt.xlabel('Orbital Radius cubed (m^3)') plt.ylabel('Orbital Period squared (s^2)') plt.title('Verification of Kepler\\'s Third Law') plt.grid(True) plt.legend() plt.show() print(\"Orbital periods (years):\", periods_years)","title":"4. Computational Model (Python)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extensions","text":"Elliptical Orbits: Kepler\u2019s Third Law generalizes using semi-major axis \\(a\\) : \\[ T^2 \\propto a^3 \\] Multiple Body Systems: Requires numerical integration for complex gravitational interactions. Relativistic Corrections: For strong gravity (e.g., near black holes).","title":"5. Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"Derived \\(T^2 \\propto r^3\\) for circular orbits. Explained its significance in astronomy and satellite mechanics. Verified using example orbital data. Provided a Python simulation and visualization.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Introduction and Motivation The concept of escape velocity is fundamental in astrophysics and space exploration. It determines the minimum speed needed for an object to break free from the gravitational pull of a celestial body without additional propulsion. Building on escape velocity, the first , second , and third cosmic velocities represent important speed thresholds for different kinds of motion relative to planets and stars: First cosmic velocity : speed to maintain a stable circular orbit just above a planet\u2019s surface. Second cosmic velocity (escape velocity) : speed to leave a planet\u2019s gravitational field. Third cosmic velocity : speed needed to escape the gravitational pull of the entire star system (e.g., the Sun\u2019s gravity for Earth). These velocities guide the design of satellites, interplanetary spacecraft, and concepts for interstellar travel. 2. Definitions and Physical Meaning First Cosmic Velocity Also called orbital velocity at the surface. Minimum horizontal speed to orbit a planet in a circular path close to the surface. \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] where: \\(G\\) is gravitational constant, \\(M\\) is mass of the planet, \\(R\\) is radius of the planet. Second Cosmic Velocity (Escape Velocity) Minimum speed to escape the gravitational field without further propulsion. \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} v_1 \\] This velocity comes from conservation of energy, where kinetic energy equals gravitational potential energy. Third Cosmic Velocity Speed to escape the gravitational field of the star system (e.g., escape Sun\u2019s gravity from Earth\u2019s orbit). For Earth escaping Sun\u2019s gravity: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2} = \\sqrt{2GM_{\\odot}/d} + v_{\\text{orbital}}^2 \\] More precisely, the speed required at Earth's orbit to leave the Sun\u2019s influence, where \\(M_{\\odot}\\) = mass of the Sun, \\(d\\) = Earth-Sun distance, \\(v_{\\text{orbital}}\\) = Earth\u2019s orbital velocity around the Sun. 3. Mathematical Derivations First Cosmic Velocity From Newton's law for circular orbit: \\[ F_c = F_g \\implies \\frac{mv_1^2}{R} = \\frac{GMm}{R^2} \\Rightarrow v_1 = \\sqrt{\\frac{GM}{R}} \\] Second Cosmic Velocity Energy conservation between surface and infinity: \\[ \\frac{1}{2} m v_2^2 = \\frac{GMm}{R} \\implies v_2 = \\sqrt{\\frac{2GM}{R}} \\] Third Cosmic Velocity The third cosmic velocity combines escape velocity from Earth and Sun. At Earth orbit radius \\(d\\) : \\[ v_{\\text{esc, Sun}} = \\sqrt{\\frac{2GM_{\\odot}}{d}} \\] Earth's orbital speed around Sun: \\[ v_{\\text{orbital}} = \\sqrt{\\frac{GM_{\\odot}}{d}} \\] The spacecraft needs to overcome Sun's gravity from Earth's orbital velocity, thus: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2} = \\sqrt{2GM/R + GM_{\\odot}/d} \\] But practically, third cosmic velocity is often approximated by: \\[ v_3 \\approx 42.1 \\text{ km/s} \\quad \\text{(from Earth)} \\] 4. Parameters Affecting Cosmic Velocities Mass \\(M\\) and radius \\(R\\) of celestial bodies influence first and second cosmic velocities. Distance \\(d\\) from star influences the third cosmic velocity. For gas giants like Jupiter with large \\(M\\) and \\(R\\) , escape velocities are much higher. Atmospheres, rotation, and shape irregularities can modify these values in practice. 5. Calculations and Visualization for Earth, Mars, Jupiter Physical constants and data Planet Mass (kg) Radius (m) Surface Gravity (m/s\u00b2) Earth \\(5.97 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) 9.81 Mars \\(6.39 \\times 10^{23}\\) \\(3.39 \\times 10^6\\) 3.71 Jupiter \\(1.90 \\times 10^{27}\\) \\(6.99 \\times 10^7\\) 24.79 Sun\u2019s mass \\(M_{\\odot} = 1.989 \\times 10^{30}\\) kg, Earth-Sun distance \\(d = 1.496 \\times 10^{11}\\) m. 6. Python Implementation with 3D Plots We'll plot the first and second cosmic velocities as a function of radius and mass, and illustrate third cosmic velocity at Earth's orbit. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Gravitational constant G = 6.67430e-11 # Define ranges for mass (kg) and radius (m) for hypothetical planets mass_range = np.linspace(1e23, 2e27, 100) # 1e23 to 2e27 kg radius_range = np.linspace(1e6, 8e7, 100) # 1e6 to 8e7 meters Mass, Radius = np.meshgrid(mass_range, radius_range) # First cosmic velocity v1 = np.sqrt(G * Mass / Radius) # Second cosmic velocity (escape velocity) v2 = np.sqrt(2) * v1 # 3D Plot for First Cosmic Velocity fig = plt.figure(figsize=(14, 6)) ax1 = fig.add_subplot(121, projection='3d') surf1 = ax1.plot_surface(Mass, Radius, v1 / 1e3, cmap='viridis') # km/s ax1.set_title('First Cosmic Velocity (Orbital Velocity) [km/s]') ax1.set_xlabel('Mass (kg)') ax1.set_ylabel('Radius (m)') ax1.set_zlabel('Velocity (km/s)') fig.colorbar(surf1, ax=ax1, shrink=0.5, aspect=5) # 3D Plot for Second Cosmic Velocity ax2 = fig.add_subplot(122, projection='3d') surf2 = ax2.plot_surface(Mass, Radius, v2 / 1e3, cmap='inferno') # km/s ax2.set_title('Second Cosmic Velocity (Escape Velocity) [km/s]') ax2.set_xlabel('Mass (kg)') ax2.set_ylabel('Radius (m)') ax2.set_zlabel('Velocity (km/s)') fig.colorbar(surf2, ax=ax2, shrink=0.5, aspect=5) plt.tight_layout() plt.show() Calculating cosmic velocities for Earth, Mars, Jupiter # Planet data planets = { 'Earth': {'M': 5.97e24, 'R': 6.371e6}, 'Mars': {'M': 6.39e23, 'R': 3.39e6}, 'Jupiter': {'M': 1.90e27, 'R': 6.99e7} } for name, data in planets.items(): v1 = np.sqrt(G * data['M'] / data['R']) v2 = np.sqrt(2) * v1 print(f\"{name}:\\n First Cosmic Velocity (v1): {v1/1e3:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {v2/1e3:.2f} km/s\\n\") # Third cosmic velocity from Earth (escaping Sun) M_sun = 1.989e30 d_earth_sun = 1.496e11 v_esc_sun = np.sqrt(2 * G * M_sun / d_earth_sun) # Escape from Sun at Earth orbit v_orbital_earth = np.sqrt(G * M_sun / d_earth_sun) v3 = np.sqrt(v_esc_sun**2 + v_orbital_earth**2) print(f\"Third Cosmic Velocity (Earth escaping Sun): {v3/1e3:.2f} km/s\") Earth: First Cosmic Velocity (v1): 7.91 km/s Second Cosmic Velocity (v2): 11.18 km/s Mars: First Cosmic Velocity (v1): 3.55 km/s Second Cosmic Velocity (v2): 5.02 km/s Jupiter: First Cosmic Velocity (v1): 42.59 km/s Second Cosmic Velocity (v2): 60.24 km/s Third Cosmic Velocity (Earth escaping Sun): 51.60 km/s 7. Importance in Space Exploration Launching Satellites: Must reach at least first cosmic velocity to maintain orbit. Leaving Earth: Rockets must achieve or exceed escape velocity. Interplanetary Travel: Escaping Earth\u2019s gravity and entering transfer orbits (third cosmic velocity) critical for missions to other planets. Interstellar Missions: Third cosmic velocity sets baseline for leaving star systems. 8. Summary Defined and derived first, second, and third cosmic velocities. Illustrated how mass and radius influence these velocities. Computed velocities for Earth, Mars, Jupiter, and Sun-Earth system. Created 3D visualizations to explore velocity dependencies. Discussed critical role of cosmic velocities in space mission design.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-introduction-and-motivation","text":"The concept of escape velocity is fundamental in astrophysics and space exploration. It determines the minimum speed needed for an object to break free from the gravitational pull of a celestial body without additional propulsion. Building on escape velocity, the first , second , and third cosmic velocities represent important speed thresholds for different kinds of motion relative to planets and stars: First cosmic velocity : speed to maintain a stable circular orbit just above a planet\u2019s surface. Second cosmic velocity (escape velocity) : speed to leave a planet\u2019s gravitational field. Third cosmic velocity : speed needed to escape the gravitational pull of the entire star system (e.g., the Sun\u2019s gravity for Earth). These velocities guide the design of satellites, interplanetary spacecraft, and concepts for interstellar travel.","title":"1. Introduction and Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-definitions-and-physical-meaning","text":"","title":"2. Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity","text":"Also called orbital velocity at the surface. Minimum horizontal speed to orbit a planet in a circular path close to the surface. \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] where: \\(G\\) is gravitational constant, \\(M\\) is mass of the planet, \\(R\\) is radius of the planet.","title":"First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"Minimum speed to escape the gravitational field without further propulsion. \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} v_1 \\] This velocity comes from conservation of energy, where kinetic energy equals gravitational potential energy.","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"Speed to escape the gravitational field of the star system (e.g., escape Sun\u2019s gravity from Earth\u2019s orbit). For Earth escaping Sun\u2019s gravity: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2} = \\sqrt{2GM_{\\odot}/d} + v_{\\text{orbital}}^2 \\] More precisely, the speed required at Earth's orbit to leave the Sun\u2019s influence, where \\(M_{\\odot}\\) = mass of the Sun, \\(d\\) = Earth-Sun distance, \\(v_{\\text{orbital}}\\) = Earth\u2019s orbital velocity around the Sun.","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-mathematical-derivations","text":"","title":"3. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity_1","text":"From Newton's law for circular orbit: \\[ F_c = F_g \\implies \\frac{mv_1^2}{R} = \\frac{GMm}{R^2} \\Rightarrow v_1 = \\sqrt{\\frac{GM}{R}} \\]","title":"First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity","text":"Energy conservation between surface and infinity: \\[ \\frac{1}{2} m v_2^2 = \\frac{GMm}{R} \\implies v_2 = \\sqrt{\\frac{2GM}{R}} \\]","title":"Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity_1","text":"The third cosmic velocity combines escape velocity from Earth and Sun. At Earth orbit radius \\(d\\) : \\[ v_{\\text{esc, Sun}} = \\sqrt{\\frac{2GM_{\\odot}}{d}} \\] Earth's orbital speed around Sun: \\[ v_{\\text{orbital}} = \\sqrt{\\frac{GM_{\\odot}}{d}} \\] The spacecraft needs to overcome Sun's gravity from Earth's orbital velocity, thus: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2} = \\sqrt{2GM/R + GM_{\\odot}/d} \\] But practically, third cosmic velocity is often approximated by: \\[ v_3 \\approx 42.1 \\text{ km/s} \\quad \\text{(from Earth)} \\]","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-parameters-affecting-cosmic-velocities","text":"Mass \\(M\\) and radius \\(R\\) of celestial bodies influence first and second cosmic velocities. Distance \\(d\\) from star influences the third cosmic velocity. For gas giants like Jupiter with large \\(M\\) and \\(R\\) , escape velocities are much higher. Atmospheres, rotation, and shape irregularities can modify these values in practice.","title":"4. Parameters Affecting Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-calculations-and-visualization-for-earth-mars-jupiter","text":"","title":"5. Calculations and Visualization for Earth, Mars, Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#physical-constants-and-data","text":"Planet Mass (kg) Radius (m) Surface Gravity (m/s\u00b2) Earth \\(5.97 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) 9.81 Mars \\(6.39 \\times 10^{23}\\) \\(3.39 \\times 10^6\\) 3.71 Jupiter \\(1.90 \\times 10^{27}\\) \\(6.99 \\times 10^7\\) 24.79 Sun\u2019s mass \\(M_{\\odot} = 1.989 \\times 10^{30}\\) kg, Earth-Sun distance \\(d = 1.496 \\times 10^{11}\\) m.","title":"Physical constants and data"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-python-implementation-with-3d-plots","text":"We'll plot the first and second cosmic velocities as a function of radius and mass, and illustrate third cosmic velocity at Earth's orbit. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Gravitational constant G = 6.67430e-11 # Define ranges for mass (kg) and radius (m) for hypothetical planets mass_range = np.linspace(1e23, 2e27, 100) # 1e23 to 2e27 kg radius_range = np.linspace(1e6, 8e7, 100) # 1e6 to 8e7 meters Mass, Radius = np.meshgrid(mass_range, radius_range) # First cosmic velocity v1 = np.sqrt(G * Mass / Radius) # Second cosmic velocity (escape velocity) v2 = np.sqrt(2) * v1 # 3D Plot for First Cosmic Velocity fig = plt.figure(figsize=(14, 6)) ax1 = fig.add_subplot(121, projection='3d') surf1 = ax1.plot_surface(Mass, Radius, v1 / 1e3, cmap='viridis') # km/s ax1.set_title('First Cosmic Velocity (Orbital Velocity) [km/s]') ax1.set_xlabel('Mass (kg)') ax1.set_ylabel('Radius (m)') ax1.set_zlabel('Velocity (km/s)') fig.colorbar(surf1, ax=ax1, shrink=0.5, aspect=5) # 3D Plot for Second Cosmic Velocity ax2 = fig.add_subplot(122, projection='3d') surf2 = ax2.plot_surface(Mass, Radius, v2 / 1e3, cmap='inferno') # km/s ax2.set_title('Second Cosmic Velocity (Escape Velocity) [km/s]') ax2.set_xlabel('Mass (kg)') ax2.set_ylabel('Radius (m)') ax2.set_zlabel('Velocity (km/s)') fig.colorbar(surf2, ax=ax2, shrink=0.5, aspect=5) plt.tight_layout() plt.show()","title":"6. Python Implementation with 3D Plots"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculating-cosmic-velocities-for-earth-mars-jupiter","text":"# Planet data planets = { 'Earth': {'M': 5.97e24, 'R': 6.371e6}, 'Mars': {'M': 6.39e23, 'R': 3.39e6}, 'Jupiter': {'M': 1.90e27, 'R': 6.99e7} } for name, data in planets.items(): v1 = np.sqrt(G * data['M'] / data['R']) v2 = np.sqrt(2) * v1 print(f\"{name}:\\n First Cosmic Velocity (v1): {v1/1e3:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {v2/1e3:.2f} km/s\\n\") # Third cosmic velocity from Earth (escaping Sun) M_sun = 1.989e30 d_earth_sun = 1.496e11 v_esc_sun = np.sqrt(2 * G * M_sun / d_earth_sun) # Escape from Sun at Earth orbit v_orbital_earth = np.sqrt(G * M_sun / d_earth_sun) v3 = np.sqrt(v_esc_sun**2 + v_orbital_earth**2) print(f\"Third Cosmic Velocity (Earth escaping Sun): {v3/1e3:.2f} km/s\") Earth: First Cosmic Velocity (v1): 7.91 km/s Second Cosmic Velocity (v2): 11.18 km/s Mars: First Cosmic Velocity (v1): 3.55 km/s Second Cosmic Velocity (v2): 5.02 km/s Jupiter: First Cosmic Velocity (v1): 42.59 km/s Second Cosmic Velocity (v2): 60.24 km/s Third Cosmic Velocity (Earth escaping Sun): 51.60 km/s","title":"Calculating cosmic velocities for Earth, Mars, Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#7-importance-in-space-exploration","text":"Launching Satellites: Must reach at least first cosmic velocity to maintain orbit. Leaving Earth: Rockets must achieve or exceed escape velocity. Interplanetary Travel: Escaping Earth\u2019s gravity and entering transfer orbits (third cosmic velocity) critical for missions to other planets. Interstellar Missions: Third cosmic velocity sets baseline for leaving star systems.","title":"7. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#8-summary","text":"Defined and derived first, second, and third cosmic velocities. Illustrated how mass and radius influence these velocities. Computed velocities for Earth, Mars, Jupiter, and Sun-Earth system. Created 3D visualizations to explore velocity dependencies. Discussed critical role of cosmic velocities in space mission design.","title":"8. Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth 1. Introduction and Motivation When a payload is released from a moving rocket near Earth, its subsequent path depends on its initial position, velocity, and the gravitational pull of Earth. The possible trajectories include: Elliptical orbits (including circular), Parabolic trajectories (escape at exactly escape velocity), Hyperbolic trajectories (escape with velocity greater than escape velocity), Suborbital (ballistic) trajectories leading to reentry. Understanding these paths is crucial for: Satellite deployment, Controlled reentry of space vehicles, Planning interplanetary missions. 2. Theoretical Background Newton\u2019s Law of Universal Gravitation The gravitational acceleration experienced by the payload at position \\(\\mathbf{r}\\) relative to Earth's center is: \\[ \\mathbf{a} = -\\frac{GM}{|\\mathbf{r}|^3} \\mathbf{r} \\] where: \\(G\\) = gravitational constant, \\(M\\) = mass of Earth, \\(\\mathbf{r}\\) = position vector of the payload relative to Earth\u2019s center. Orbital Energy and Trajectory Types Total specific mechanical energy \\(\\varepsilon\\) of the payload (per unit mass) determines trajectory type: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] \\(\\varepsilon < 0\\) : Elliptical orbit (closed), \\(\\varepsilon = 0\\) : Parabolic trajectory (critical escape), \\(\\varepsilon > 0\\) : Hyperbolic trajectory (unbound escape). Orbital Elements (Optional) From initial \\(\\mathbf{r}\\) and velocity \\(\\mathbf{v}\\) , orbital parameters such as semi-major axis, eccentricity, and inclination can be derived, but for simulation we focus on trajectory integration. 3. Numerical Simulation Approach Equations of Motion (2D simplification) We model the payload\u2019s motion in the plane: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] \\[ \\frac{d\\mathbf{v}}{dt} = - \\frac{GM}{r^3} \\mathbf{r} \\] Numerical Integration Method Use numerical ODE solvers like Runge-Kutta (RK4 or RK45) to integrate position and velocity over time, given initial conditions: Initial position vector \\(\\mathbf{r}_0\\) , Initial velocity vector \\(\\mathbf{v}_0\\) . 4. Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_earth = 5.972e24 # kg R_earth = 6.371e6 # m def gravity_ode(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y_pos / r**3 return [vx, vy, ax, ay] def simulate_trajectory(r0, v0, t_span, max_step=1): y0 = [r0[0], r0[1], v0[0], v0[1]] sol = solve_ivp(gravity_ode, t_span, y0, max_step=max_step, rtol=1e-8, atol=1e-8) return sol # Example Initial Conditions: # Payload released 300 km above Earth surface (circular orbit altitude) altitude = 300e3 # 300 km r0_mag = R_earth + altitude r0 = np.array([r0_mag, 0]) # Starting on x-axis # Circular orbital velocity at altitude: v_circ = np.sqrt(G * M_earth / r0_mag) v0_circular = np.array([0, v_circ]) # Velocity perpendicular to radius vector # Slightly less velocity for suborbital trajectory (will reenter) v0_suborbital = v0_circular * 0.9 # Greater than escape velocity for hyperbolic trajectory v_escape = np.sqrt(2 * G * M_earth / r0_mag) v0_escape = np.array([0, v_escape * 1.1]) # Simulate all three cases t_span = (0, 6000) # seconds (about 1.7 hours) sol_circular = simulate_trajectory(r0, v0_circular, t_span) sol_suborbital = simulate_trajectory(r0, v0_suborbital, t_span) sol_escape = simulate_trajectory(r0, v0_escape, t_span) # Plot trajectories plt.figure(figsize=(10,10)) # Earth for reference earth = plt.Circle((0,0), R_earth, color='blue', alpha=0.3) plt.gca().add_artist(earth) plt.plot(sol_circular.y[0], sol_circular.y[1], label='Circular Orbit') plt.plot(sol_suborbital.y[0], sol_suborbital.y[1], label='Suborbital (Reentry)') plt.plot(sol_escape.y[0], sol_escape.y[1], label='Escape Trajectory') plt.scatter([r0[0]], [r0[1]], color='black', label='Release Point') plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Payload Trajectories near Earth') plt.legend() plt.axis('equal') plt.grid(True) plt.show() 5. Explanation of Results Circular Orbit: The payload velocity matches the circular orbital velocity, maintaining a stable orbit. Suborbital: Velocity is insufficient to stay in orbit; the payload follows a ballistic trajectory and reenters the atmosphere. Escape Trajectory: Velocity exceeds escape velocity; the payload follows a hyperbolic path, leaving Earth\u2019s gravitational influence. 6. Applications Satellite Deployment: Ensuring the payload reaches appropriate orbit velocity. Reentry Vehicles: Planning controlled descent paths. Interplanetary Missions: Releasing payloads at escape velocity to begin transfer orbits. 7. Extensions and Further Work 3D Trajectory Simulation: Include inclination and full 3D vector initial conditions. Atmospheric Drag: Add drag forces for realistic reentry simulation. Non-uniform Gravity: Model Earth\u2019s oblateness or gravitational anomalies. Multi-body Effects: Consider Moon and Sun gravity influences. 8. Summary Derived motion equations for a payload near Earth. Explained trajectory types via total energy. Developed a Python simulation of orbital, suborbital, and escape trajectories. Visualized the different paths, highlighting mission-relevant cases.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-introduction-and-motivation","text":"When a payload is released from a moving rocket near Earth, its subsequent path depends on its initial position, velocity, and the gravitational pull of Earth. The possible trajectories include: Elliptical orbits (including circular), Parabolic trajectories (escape at exactly escape velocity), Hyperbolic trajectories (escape with velocity greater than escape velocity), Suborbital (ballistic) trajectories leading to reentry. Understanding these paths is crucial for: Satellite deployment, Controlled reentry of space vehicles, Planning interplanetary missions.","title":"1. Introduction and Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-theoretical-background","text":"","title":"2. Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-universal-gravitation","text":"The gravitational acceleration experienced by the payload at position \\(\\mathbf{r}\\) relative to Earth's center is: \\[ \\mathbf{a} = -\\frac{GM}{|\\mathbf{r}|^3} \\mathbf{r} \\] where: \\(G\\) = gravitational constant, \\(M\\) = mass of Earth, \\(\\mathbf{r}\\) = position vector of the payload relative to Earth\u2019s center.","title":"Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-energy-and-trajectory-types","text":"Total specific mechanical energy \\(\\varepsilon\\) of the payload (per unit mass) determines trajectory type: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] \\(\\varepsilon < 0\\) : Elliptical orbit (closed), \\(\\varepsilon = 0\\) : Parabolic trajectory (critical escape), \\(\\varepsilon > 0\\) : Hyperbolic trajectory (unbound escape).","title":"Orbital Energy and Trajectory Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-elements-optional","text":"From initial \\(\\mathbf{r}\\) and velocity \\(\\mathbf{v}\\) , orbital parameters such as semi-major axis, eccentricity, and inclination can be derived, but for simulation we focus on trajectory integration.","title":"Orbital Elements (Optional)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-numerical-simulation-approach","text":"","title":"3. Numerical Simulation Approach"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion-2d-simplification","text":"We model the payload\u2019s motion in the plane: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] \\[ \\frac{d\\mathbf{v}}{dt} = - \\frac{GM}{r^3} \\mathbf{r} \\]","title":"Equations of Motion (2D simplification)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-integration-method","text":"Use numerical ODE solvers like Runge-Kutta (RK4 or RK45) to integrate position and velocity over time, given initial conditions: Initial position vector \\(\\mathbf{r}_0\\) , Initial velocity vector \\(\\mathbf{v}_0\\) .","title":"Numerical Integration Method"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_earth = 5.972e24 # kg R_earth = 6.371e6 # m def gravity_ode(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y_pos / r**3 return [vx, vy, ax, ay] def simulate_trajectory(r0, v0, t_span, max_step=1): y0 = [r0[0], r0[1], v0[0], v0[1]] sol = solve_ivp(gravity_ode, t_span, y0, max_step=max_step, rtol=1e-8, atol=1e-8) return sol # Example Initial Conditions: # Payload released 300 km above Earth surface (circular orbit altitude) altitude = 300e3 # 300 km r0_mag = R_earth + altitude r0 = np.array([r0_mag, 0]) # Starting on x-axis # Circular orbital velocity at altitude: v_circ = np.sqrt(G * M_earth / r0_mag) v0_circular = np.array([0, v_circ]) # Velocity perpendicular to radius vector # Slightly less velocity for suborbital trajectory (will reenter) v0_suborbital = v0_circular * 0.9 # Greater than escape velocity for hyperbolic trajectory v_escape = np.sqrt(2 * G * M_earth / r0_mag) v0_escape = np.array([0, v_escape * 1.1]) # Simulate all three cases t_span = (0, 6000) # seconds (about 1.7 hours) sol_circular = simulate_trajectory(r0, v0_circular, t_span) sol_suborbital = simulate_trajectory(r0, v0_suborbital, t_span) sol_escape = simulate_trajectory(r0, v0_escape, t_span) # Plot trajectories plt.figure(figsize=(10,10)) # Earth for reference earth = plt.Circle((0,0), R_earth, color='blue', alpha=0.3) plt.gca().add_artist(earth) plt.plot(sol_circular.y[0], sol_circular.y[1], label='Circular Orbit') plt.plot(sol_suborbital.y[0], sol_suborbital.y[1], label='Suborbital (Reentry)') plt.plot(sol_escape.y[0], sol_escape.y[1], label='Escape Trajectory') plt.scatter([r0[0]], [r0[1]], color='black', label='Release Point') plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Payload Trajectories near Earth') plt.legend() plt.axis('equal') plt.grid(True) plt.show()","title":"4. Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-explanation-of-results","text":"Circular Orbit: The payload velocity matches the circular orbital velocity, maintaining a stable orbit. Suborbital: Velocity is insufficient to stay in orbit; the payload follows a ballistic trajectory and reenters the atmosphere. Escape Trajectory: Velocity exceeds escape velocity; the payload follows a hyperbolic path, leaving Earth\u2019s gravitational influence.","title":"5. Explanation of Results"},{"location":"1%20Physics/2%20Gravity/Problem_3/#6-applications","text":"Satellite Deployment: Ensuring the payload reaches appropriate orbit velocity. Reentry Vehicles: Planning controlled descent paths. Interplanetary Missions: Releasing payloads at escape velocity to begin transfer orbits.","title":"6. Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#7-extensions-and-further-work","text":"3D Trajectory Simulation: Include inclination and full 3D vector initial conditions. Atmospheric Drag: Add drag forces for realistic reentry simulation. Non-uniform Gravity: Model Earth\u2019s oblateness or gravitational anomalies. Multi-body Effects: Consider Moon and Sun gravity influences.","title":"7. Extensions and Further Work"},{"location":"1%20Physics/2%20Gravity/Problem_3/#8-summary","text":"Derived motion equations for a payload near Earth. Explained trajectory types via total energy. Developed a Python simulation of orbital, suborbital, and escape trajectories. Visualized the different paths, highlighting mission-relevant cases.","title":"8. Summary"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}