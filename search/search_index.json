{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Governing Equations of Projectile Motion We start from Newton\u2019s Second Law for a projectile launched in a uniform gravitational field (ignoring air resistance): \\[ \\mathbf{F} = m \\mathbf{a} \\] For a projectile of mass \\(m\\) : Horizontal direction ( \\(x\\) ): no acceleration (neglecting air resistance), so \\[ a_x = 0 \\implies \\frac{d^2 x}{dt^2} = 0 \\] Vertical direction ( \\(y\\) ): \\[ a_y = -g \\implies \\frac{d^2 y}{dt^2} = -g \\] Initial Conditions At \\(t = 0\\) : \\[ x(0) = 0, \\quad y(0) = h \\] \\[ v_x(0) = v_0 \\cos \\theta, \\quad v_y(0) = v_0 \\sin \\theta \\] where \\(v_0\\) is the initial speed, \\(\\theta\\) is the angle of projection, \\(h\\) is the initial height, \\(g\\) is gravitational acceleration. Solutions to the Equations Solving the second order ODEs: Horizontal motion: \\[ x(t) = v_0 \\cos \\theta \\cdot t \\] Vertical motion: \\[ y(t) = h + v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 \\] Time of Flight The time when projectile hits the ground ( \\(y=0\\) ): \\[ 0 = h + v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 \\] Solve quadratic in \\(t\\) : \\[ t = \\frac{v_0 \\sin \\theta + \\sqrt{(v_0 \\sin \\theta)^2 + 2 g h}}{g} \\] (Only the positive root is physically meaningful.) Horizontal Range Using \\(t\\) above, range \\(R\\) is \\[ R(\\theta) = x(t) = v_0 \\cos \\theta \\times t \\] This expression defines a family of solutions parametrized by \\(\\theta\\) , \\(v_0\\) , \\(h\\) , and \\(g\\) . 2. Analysis of the Range The range depends on the angle \\(\\theta\\) via \\(\\sin\\theta\\) and \\(\\cos\\theta\\) . For \\(h=0\\) , the well-known formula reduces to \\[ R = \\frac{v_0^2}{g} \\sin 2\\theta \\] which peaks at \\(\\theta = 45^\\circ\\) . When \\(h \\neq 0\\) , the maximum range angle shifts. Changes in \\(v_0\\) scale the range proportionally. Increasing \\(g\\) reduces the range. 3. Practical Applications Uneven terrain : Can model \\(h\\neq 0\\) . Air resistance : Requires adding drag force, typically non-linear; analytical solutions become complicated, often requiring numerical simulation. Wind : Adds horizontal acceleration component. Sports and Engineering : Ballistics, sports (soccer, basketball), launch vehicles, fireworks. 4. Implementation: Python Simulation & Visualization import numpy as np import matplotlib.pyplot as plt def time_of_flight(v0, theta, h, g=9.81): \"\"\" Calculate time of flight until projectile hits ground y=0. Parameters: v0: initial speed (m/s) theta: launch angle in radians h: initial height (m) g: gravitational acceleration (m/s^2) Returns: time_of_flight (float) \"\"\" term1 = v0 * np.sin(theta) discriminant = term1**2 + 2 * g * h t_flight = (term1 + np.sqrt(discriminant)) / g return t_flight def range_projectile(v0, theta, h, g=9.81): \"\"\" Calculate horizontal range of projectile. Parameters: v0: initial speed (m/s) theta: launch angle in radians h: initial height (m) g: gravitational acceleration (m/s^2) Returns: horizontal range (float) \"\"\" t_flight = time_of_flight(v0, theta, h, g) return v0 * np.cos(theta) * t_flight # Parameters v0 = 20 # m/s h = 0 # initial height in meters g = 9.81 # m/s^2 angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) ranges = np.array([range_projectile(v0, angle, h, g) for angle in angles_rad]) # Plot plt.figure(figsize=(10,6)) plt.plot(angles_deg, ranges) plt.title(\"Projectile Range vs Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.show() Exploring Parameters You can vary \\(v_0\\) , \\(h\\) , and \\(g\\) and plot multiple curves on the same graph: h_values = [0, 5, 10] # Different launch heights plt.figure(figsize=(10,6)) for h_i in h_values: ranges = np.array([range_projectile(v0, angle, h_i, g) for angle in angles_rad]) plt.plot(angles_deg, ranges, label=f'h = {h_i} m') plt.title(\"Projectile Range vs Launch Angle for Different Launch Heights\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid(True) plt.show() 5. Discussion on Limitations and Extensions Limitations of the Idealized Model: Ignores air resistance which can significantly reduce range and alter optimal angle. Assumes uniform gravitational field. Assumes flat ground at final landing spot (can be adapted for uneven terrain but complex). Possible Extensions: Air Drag: Model drag force \\(\\mathbf{F}_d = -\\frac{1}{2} C_d \\rho A v^2 \\hat{v}\\) , numerical integration required. Wind Effects: Add horizontal wind velocity component. Variable Gravity: For long-range trajectories (e.g., missiles, rockets), gravity changes with altitude. Spin & Magnus Effect: For sports balls. Summary Derived general projectile motion equations from first principles. Obtained formula for range as function of launch angle, initial velocity, initial height, and gravity. Demonstrated Python simulation with visualizations. Discussed real-world applicability and model limitations.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations-of-projectile-motion","text":"We start from Newton\u2019s Second Law for a projectile launched in a uniform gravitational field (ignoring air resistance): \\[ \\mathbf{F} = m \\mathbf{a} \\] For a projectile of mass \\(m\\) : Horizontal direction ( \\(x\\) ): no acceleration (neglecting air resistance), so \\[ a_x = 0 \\implies \\frac{d^2 x}{dt^2} = 0 \\] Vertical direction ( \\(y\\) ): \\[ a_y = -g \\implies \\frac{d^2 y}{dt^2} = -g \\]","title":"Governing Equations of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#initial-conditions","text":"At \\(t = 0\\) : \\[ x(0) = 0, \\quad y(0) = h \\] \\[ v_x(0) = v_0 \\cos \\theta, \\quad v_y(0) = v_0 \\sin \\theta \\] where \\(v_0\\) is the initial speed, \\(\\theta\\) is the angle of projection, \\(h\\) is the initial height, \\(g\\) is gravitational acceleration.","title":"Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solutions-to-the-equations","text":"Solving the second order ODEs: Horizontal motion: \\[ x(t) = v_0 \\cos \\theta \\cdot t \\] Vertical motion: \\[ y(t) = h + v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 \\]","title":"Solutions to the Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The time when projectile hits the ground ( \\(y=0\\) ): \\[ 0 = h + v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 \\] Solve quadratic in \\(t\\) : \\[ t = \\frac{v_0 \\sin \\theta + \\sqrt{(v_0 \\sin \\theta)^2 + 2 g h}}{g} \\] (Only the positive root is physically meaningful.)","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-range","text":"Using \\(t\\) above, range \\(R\\) is \\[ R(\\theta) = x(t) = v_0 \\cos \\theta \\times t \\] This expression defines a family of solutions parametrized by \\(\\theta\\) , \\(v_0\\) , \\(h\\) , and \\(g\\) .","title":"Horizontal Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range depends on the angle \\(\\theta\\) via \\(\\sin\\theta\\) and \\(\\cos\\theta\\) . For \\(h=0\\) , the well-known formula reduces to \\[ R = \\frac{v_0^2}{g} \\sin 2\\theta \\] which peaks at \\(\\theta = 45^\\circ\\) . When \\(h \\neq 0\\) , the maximum range angle shifts. Changes in \\(v_0\\) scale the range proportionally. Increasing \\(g\\) reduces the range.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Uneven terrain : Can model \\(h\\neq 0\\) . Air resistance : Requires adding drag force, typically non-linear; analytical solutions become complicated, often requiring numerical simulation. Wind : Adds horizontal acceleration component. Sports and Engineering : Ballistics, sports (soccer, basketball), launch vehicles, fireworks.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-simulation-visualization","text":"import numpy as np import matplotlib.pyplot as plt def time_of_flight(v0, theta, h, g=9.81): \"\"\" Calculate time of flight until projectile hits ground y=0. Parameters: v0: initial speed (m/s) theta: launch angle in radians h: initial height (m) g: gravitational acceleration (m/s^2) Returns: time_of_flight (float) \"\"\" term1 = v0 * np.sin(theta) discriminant = term1**2 + 2 * g * h t_flight = (term1 + np.sqrt(discriminant)) / g return t_flight def range_projectile(v0, theta, h, g=9.81): \"\"\" Calculate horizontal range of projectile. Parameters: v0: initial speed (m/s) theta: launch angle in radians h: initial height (m) g: gravitational acceleration (m/s^2) Returns: horizontal range (float) \"\"\" t_flight = time_of_flight(v0, theta, h, g) return v0 * np.cos(theta) * t_flight # Parameters v0 = 20 # m/s h = 0 # initial height in meters g = 9.81 # m/s^2 angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) ranges = np.array([range_projectile(v0, angle, h, g) for angle in angles_rad]) # Plot plt.figure(figsize=(10,6)) plt.plot(angles_deg, ranges) plt.title(\"Projectile Range vs Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.show()","title":"4. Implementation: Python Simulation &amp; Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#exploring-parameters","text":"You can vary \\(v_0\\) , \\(h\\) , and \\(g\\) and plot multiple curves on the same graph: h_values = [0, 5, 10] # Different launch heights plt.figure(figsize=(10,6)) for h_i in h_values: ranges = np.array([range_projectile(v0, angle, h_i, g) for angle in angles_rad]) plt.plot(angles_deg, ranges, label=f'h = {h_i} m') plt.title(\"Projectile Range vs Launch Angle for Different Launch Heights\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid(True) plt.show()","title":"Exploring Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-discussion-on-limitations-and-extensions","text":"Limitations of the Idealized Model: Ignores air resistance which can significantly reduce range and alter optimal angle. Assumes uniform gravitational field. Assumes flat ground at final landing spot (can be adapted for uneven terrain but complex). Possible Extensions: Air Drag: Model drag force \\(\\mathbf{F}_d = -\\frac{1}{2} C_d \\rho A v^2 \\hat{v}\\) , numerical integration required. Wind Effects: Add horizontal wind velocity component. Variable Gravity: For long-range trajectories (e.g., missiles, rockets), gravity changes with altitude. Spin & Magnus Effect: For sports balls.","title":"5. Discussion on Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary","text":"Derived general projectile motion equations from first principles. Obtained formula for range as function of launch angle, initial velocity, initial height, and gravity. Demonstrated Python simulation with visualizations. Discussed real-world applicability and model limitations.","title":"Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Solution for Problem 2: Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation Differential Equation The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin \\theta = A \\cos(\\omega t) \\] where \\(\\theta(t)\\) : angular displacement, \\(b\\) : damping coefficient, \\(g\\) : acceleration due to gravity, \\(L\\) : length of the pendulum, \\(A\\) : amplitude of external driving torque, \\(\\omega\\) : angular frequency of driving force. Small-Angle Approximation For small oscillations, \\(\\sin \\theta \\approx \\theta\\) . The equation becomes linear: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] Homogeneous Solution (No Driving Force) The characteristic equation: \\[ r^2 + b r + \\frac{g}{L} = 0 \\] Solutions: \\[ r = \\frac{-b \\pm \\sqrt{b^2 - 4 \\frac{g}{L}}}{2} \\] Underdamped ( \\(b^2 < 4g/L\\) ): Oscillatory decay. Overdamped ( \\(b^2 > 4g/L\\) ): Exponential decay without oscillation. Critically damped ( \\(b^2 = 4g/L\\) ). Particular Solution (Steady-State Forced Response) Assuming steady-state solution of form: \\[ \\theta_p = \\Theta \\cos(\\omega t - \\delta) \\] Plug into differential equation and solve for amplitude \\(\\Theta\\) : \\[ \\Theta = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + b^2 \\omega^2}} \\] Phase lag \\(\\delta\\) satisfies: \\[ \\tan \\delta = \\frac{b \\omega}{\\frac{g}{L} - \\omega^2} \\] Resonance Condition Resonance approximately occurs when the driving frequency matches the natural frequency of the system (undamped): \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] The presence of damping \\(b\\) shifts and broadens the resonance peak. 2. Analysis of Dynamics Damping \\(b\\) : Increasing damping reduces amplitude, broadens resonance peak, and suppresses chaos. Driving amplitude \\(A\\) : Larger amplitudes can push the system into nonlinear and chaotic regimes. Driving frequency \\(\\omega\\) : Changes in frequency cause resonance effects; near \\(\\omega_0\\) , amplitude peaks. Nonlinearity ( \\(\\sin \\theta\\) ) : For large \\(\\theta\\) , the system exhibits complex dynamics including period doubling and chaos. 3. Practical Applications Energy Harvesting: Mechanical oscillators capturing ambient vibrations often modeled as forced damped pendulums. Suspension Bridges: Forced oscillations due to wind or traffic forces modeled similarly to study resonance risks. Oscillating Circuits: RLC circuits with external AC sources show analogous behavior. Biomechanics: Human gait analyzed with forced oscillator models. 4. Implementation: Python Simulation We use numerical integration (Runge-Kutta 4th order) to solve the nonlinear ODE. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # m/s^2 L = 1.0 # meters b = 0.5 # damping coefficient A = 1.2 # driving amplitude omega = 2/3 # driving frequency # System of first order ODEs: # Let y = [theta, omega_theta], where omega_theta = dtheta/dt def forced_damped_pendulum(t, y): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -b * omega_theta - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span t_span = (0, 60) t_eval = np.linspace(*t_span, 1000) # Initial conditions: theta=0.2 rad, omega=0 y0 = [0.2, 0.0] # Solve ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot angular displacement over time plt.figure(figsize=(10,4)) plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum: Angular Displacement vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.grid(True) plt.show() # Phase space plot (\u03b8 vs \u03c9) plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[1]) plt.title(\"Phase Space of Forced Damped Pendulum\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular velocity \u03c9 (rad/s)\") plt.grid(True) plt.show() 5. Extending the Analysis: Poincar\u00e9 Section To analyze transitions to chaos, sample the system at driving period intervals \\(T = \\frac{2\\pi}{\\omega}\\) : T = 2 * np.pi / omega poincare_times = np.arange(0, t_span[1], T) # Interpolate solution at Poincare times theta_poincare = np.interp(poincare_times, sol.t, sol.y[0]) omega_poincare = np.interp(poincare_times, sol.t, sol.y[1]) plt.figure(figsize=(6,6)) plt.scatter(theta_poincare, omega_poincare, s=10, color='red') plt.title(\"Poincar\u00e9 Section of Forced Damped Pendulum\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular velocity \u03c9 (rad/s)\") plt.grid(True) plt.show() 6. Discussion on Limitations and Extensions Nonlinearity: Full nonlinear \\(\\sin \\theta\\) model necessary for large oscillations. Numerical Sensitivity: Chaotic regimes require fine resolution and careful numerical methods. Extensions: Introduce nonlinear damping, non-periodic forcing, or coupling multiple pendulums. Physical factors: Air resistance, structural flex, and other real-world factors not included here. Summary Derived and analyzed forced damped pendulum equations. Explored approximate linear solutions and resonance. Created computational models to simulate and visualize behavior. Used phase space and Poincar\u00e9 sections to identify chaotic transitions. Discussed real-world relevance and possible extensions.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solution-for-problem-2-dynamics-of-a-forced-damped-pendulum","text":"","title":"Solution for Problem 2: Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation","text":"The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin \\theta = A \\cos(\\omega t) \\] where \\(\\theta(t)\\) : angular displacement, \\(b\\) : damping coefficient, \\(g\\) : acceleration due to gravity, \\(L\\) : length of the pendulum, \\(A\\) : amplitude of external driving torque, \\(\\omega\\) : angular frequency of driving force.","title":"Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations, \\(\\sin \\theta \\approx \\theta\\) . The equation becomes linear: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\]","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#homogeneous-solution-no-driving-force","text":"The characteristic equation: \\[ r^2 + b r + \\frac{g}{L} = 0 \\] Solutions: \\[ r = \\frac{-b \\pm \\sqrt{b^2 - 4 \\frac{g}{L}}}{2} \\] Underdamped ( \\(b^2 < 4g/L\\) ): Oscillatory decay. Overdamped ( \\(b^2 > 4g/L\\) ): Exponential decay without oscillation. Critically damped ( \\(b^2 = 4g/L\\) ).","title":"Homogeneous Solution (No Driving Force)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#particular-solution-steady-state-forced-response","text":"Assuming steady-state solution of form: \\[ \\theta_p = \\Theta \\cos(\\omega t - \\delta) \\] Plug into differential equation and solve for amplitude \\(\\Theta\\) : \\[ \\Theta = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + b^2 \\omega^2}} \\] Phase lag \\(\\delta\\) satisfies: \\[ \\tan \\delta = \\frac{b \\omega}{\\frac{g}{L} - \\omega^2} \\]","title":"Particular Solution (Steady-State Forced Response)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance approximately occurs when the driving frequency matches the natural frequency of the system (undamped): \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] The presence of damping \\(b\\) shifts and broadens the resonance peak.","title":"Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Damping \\(b\\) : Increasing damping reduces amplitude, broadens resonance peak, and suppresses chaos. Driving amplitude \\(A\\) : Larger amplitudes can push the system into nonlinear and chaotic regimes. Driving frequency \\(\\omega\\) : Changes in frequency cause resonance effects; near \\(\\omega_0\\) , amplitude peaks. Nonlinearity ( \\(\\sin \\theta\\) ) : For large \\(\\theta\\) , the system exhibits complex dynamics including period doubling and chaos.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting: Mechanical oscillators capturing ambient vibrations often modeled as forced damped pendulums. Suspension Bridges: Forced oscillations due to wind or traffic forces modeled similarly to study resonance risks. Oscillating Circuits: RLC circuits with external AC sources show analogous behavior. Biomechanics: Human gait analyzed with forced oscillator models.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"We use numerical integration (Runge-Kutta 4th order) to solve the nonlinear ODE. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # m/s^2 L = 1.0 # meters b = 0.5 # damping coefficient A = 1.2 # driving amplitude omega = 2/3 # driving frequency # System of first order ODEs: # Let y = [theta, omega_theta], where omega_theta = dtheta/dt def forced_damped_pendulum(t, y): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -b * omega_theta - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span t_span = (0, 60) t_eval = np.linspace(*t_span, 1000) # Initial conditions: theta=0.2 rad, omega=0 y0 = [0.2, 0.0] # Solve ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot angular displacement over time plt.figure(figsize=(10,4)) plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum: Angular Displacement vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.grid(True) plt.show() # Phase space plot (\u03b8 vs \u03c9) plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[1]) plt.title(\"Phase Space of Forced Damped Pendulum\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular velocity \u03c9 (rad/s)\") plt.grid(True) plt.show()","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-extending-the-analysis-poincare-section","text":"To analyze transitions to chaos, sample the system at driving period intervals \\(T = \\frac{2\\pi}{\\omega}\\) : T = 2 * np.pi / omega poincare_times = np.arange(0, t_span[1], T) # Interpolate solution at Poincare times theta_poincare = np.interp(poincare_times, sol.t, sol.y[0]) omega_poincare = np.interp(poincare_times, sol.t, sol.y[1]) plt.figure(figsize=(6,6)) plt.scatter(theta_poincare, omega_poincare, s=10, color='red') plt.title(\"Poincar\u00e9 Section of Forced Damped Pendulum\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular velocity \u03c9 (rad/s)\") plt.grid(True) plt.show()","title":"5. Extending the Analysis: Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-discussion-on-limitations-and-extensions","text":"Nonlinearity: Full nonlinear \\(\\sin \\theta\\) model necessary for large oscillations. Numerical Sensitivity: Chaotic regimes require fine resolution and careful numerical methods. Extensions: Introduce nonlinear damping, non-periodic forcing, or coupling multiple pendulums. Physical factors: Air resistance, structural flex, and other real-world factors not included here.","title":"6. Discussion on Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary","text":"Derived and analyzed forced damped pendulum equations. Explored approximate linear solutions and resonance. Created computational models to simulate and visualize behavior. Used phase space and Poincar\u00e9 sections to identify chaotic transitions. Discussed real-world relevance and possible extensions.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Solution: Orbital Period and Orbital Radius (Kepler\u2019s Third Law) 1. Theoretical Derivation For a body of mass \\(m\\) orbiting a much larger mass \\(M\\) (e.g., a planet orbiting the Sun), under Newtonian gravity, the gravitational force provides the centripetal force required for circular motion: \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = m \\frac{v^2}{r} \\] where: \\(G\\) = gravitational constant, \\(r\\) = orbital radius, \\(v\\) = orbital speed. Simplify: \\[ v^2 = \\frac{G M}{r} \\] Orbital period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2 \\pi r}{v} \\] Substitute \\(v\\) : \\[ T = 2 \\pi r \\sqrt{\\frac{r}{G M}} = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\] Square both sides: \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] This is Kepler\u2019s Third Law for circular orbits: the square of the period is proportional to the cube of the radius. 2. Implications in Astronomy Determining Planetary Masses: Given \\(T\\) and \\(r\\) , one can estimate the mass \\(M\\) of the central body. Satellite Orbits: Used to design orbits with desired periods. Distance Measurements: Helps infer distances in planetary and stellar systems. Foundation for Elliptical Orbits: Kepler\u2019s law extends to elliptical orbits with \\(r^3\\) replaced by the cube of the semi-major axis. 3. Real-World Examples Moon-Earth System: \\(r \\approx 3.84 \\times 10^8\\) m, \\(T \\approx 27.3\\) days, Using \\(M_{\\text{Earth}} \\approx 5.97 \\times 10^{24}\\) kg, the formula holds closely. Planets in Solar System: Plotting \\(T^2\\) vs. \\(r^3\\) shows linear relationship confirming the law. 4. Computational Model (Python) import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Orbital radii in meters (Earth, Mars, Jupiter) radii = np.array([1.496e11, 2.279e11, 7.785e11]) # Compute orbital periods using Kepler's law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M_sun)) # Convert periods from seconds to Earth years periods_years = periods / (60 * 60 * 24 * 365.25) # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii**3, periods**2, 'o-', label='Computed data') plt.xlabel('Orbital Radius cubed (m^3)') plt.ylabel('Orbital Period squared (s^2)') plt.title('Verification of Kepler\\'s Third Law') plt.grid(True) plt.legend() plt.show() print(\"Orbital periods (years):\", periods_years) 5. Extensions Elliptical Orbits: Kepler\u2019s Third Law generalizes using semi-major axis \\(a\\) : \\[ T^2 \\propto a^3 \\] Multiple Body Systems: Requires numerical integration for complex gravitational interactions. Relativistic Corrections: For strong gravity (e.g., near black holes). Summary Derived \\(T^2 \\propto r^3\\) for circular orbits. Explained its significance in astronomy and satellite mechanics. Verified using example orbital data. Provided a Python simulation and visualization.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#solution-orbital-period-and-orbital-radius-keplers-third-law","text":"","title":"Solution: Orbital Period and Orbital Radius (Kepler\u2019s Third Law)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"For a body of mass \\(m\\) orbiting a much larger mass \\(M\\) (e.g., a planet orbiting the Sun), under Newtonian gravity, the gravitational force provides the centripetal force required for circular motion: \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = m \\frac{v^2}{r} \\] where: \\(G\\) = gravitational constant, \\(r\\) = orbital radius, \\(v\\) = orbital speed. Simplify: \\[ v^2 = \\frac{G M}{r} \\] Orbital period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2 \\pi r}{v} \\] Substitute \\(v\\) : \\[ T = 2 \\pi r \\sqrt{\\frac{r}{G M}} = 2 \\pi \\sqrt{\\frac{r^3}{G M}} \\] Square both sides: \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] This is Kepler\u2019s Third Law for circular orbits: the square of the period is proportional to the cube of the radius.","title":"1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-in-astronomy","text":"Determining Planetary Masses: Given \\(T\\) and \\(r\\) , one can estimate the mass \\(M\\) of the central body. Satellite Orbits: Used to design orbits with desired periods. Distance Measurements: Helps infer distances in planetary and stellar systems. Foundation for Elliptical Orbits: Kepler\u2019s law extends to elliptical orbits with \\(r^3\\) replaced by the cube of the semi-major axis.","title":"2. Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"Moon-Earth System: \\(r \\approx 3.84 \\times 10^8\\) m, \\(T \\approx 27.3\\) days, Using \\(M_{\\text{Earth}} \\approx 5.97 \\times 10^{24}\\) kg, the formula holds closely. Planets in Solar System: Plotting \\(T^2\\) vs. \\(r^3\\) shows linear relationship confirming the law.","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-computational-model-python","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Orbital radii in meters (Earth, Mars, Jupiter) radii = np.array([1.496e11, 2.279e11, 7.785e11]) # Compute orbital periods using Kepler's law periods = 2 * np.pi * np.sqrt(radii**3 / (G * M_sun)) # Convert periods from seconds to Earth years periods_years = periods / (60 * 60 * 24 * 365.25) # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii**3, periods**2, 'o-', label='Computed data') plt.xlabel('Orbital Radius cubed (m^3)') plt.ylabel('Orbital Period squared (s^2)') plt.title('Verification of Kepler\\'s Third Law') plt.grid(True) plt.legend() plt.show() print(\"Orbital periods (years):\", periods_years)","title":"4. Computational Model (Python)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extensions","text":"Elliptical Orbits: Kepler\u2019s Third Law generalizes using semi-major axis \\(a\\) : \\[ T^2 \\propto a^3 \\] Multiple Body Systems: Requires numerical integration for complex gravitational interactions. Relativistic Corrections: For strong gravity (e.g., near black holes).","title":"5. Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"Derived \\(T^2 \\propto r^3\\) for circular orbits. Explained its significance in astronomy and satellite mechanics. Verified using example orbital data. Provided a Python simulation and visualization.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities 1. Introduction and Motivation The concept of escape velocity is fundamental in astrophysics and space exploration. It determines the minimum speed needed for an object to break free from the gravitational pull of a celestial body without additional propulsion. Building on escape velocity, the first , second , and third cosmic velocities represent important speed thresholds for different kinds of motion relative to planets and stars: First cosmic velocity : speed to maintain a stable circular orbit just above a planet\u2019s surface. Second cosmic velocity (escape velocity) : speed to leave a planet\u2019s gravitational field. Third cosmic velocity : speed needed to escape the gravitational pull of the entire star system (e.g., the Sun\u2019s gravity for Earth). These velocities guide the design of satellites, interplanetary spacecraft, and concepts for interstellar travel. 2. Definitions and Physical Meaning First Cosmic Velocity Also called orbital velocity at the surface. Minimum horizontal speed to orbit a planet in a circular path close to the surface. \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] where: \\(G\\) is gravitational constant, \\(M\\) is mass of the planet, \\(R\\) is radius of the planet. Second Cosmic Velocity (Escape Velocity) Minimum speed to escape the gravitational field without further propulsion. \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} v_1 \\] This velocity comes from conservation of energy, where kinetic energy equals gravitational potential energy. Third Cosmic Velocity Speed to escape the gravitational field of the star system (e.g., escape Sun\u2019s gravity from Earth\u2019s orbit). For Earth escaping Sun\u2019s gravity: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2} = \\sqrt{2GM_{\\odot}/d} + v_{\\text{orbital}}^2 \\] More precisely, the speed required at Earth's orbit to leave the Sun\u2019s influence, where \\(M_{\\odot}\\) = mass of the Sun, \\(d\\) = Earth-Sun distance, \\(v_{\\text{orbital}}\\) = Earth\u2019s orbital velocity around the Sun. 3. Mathematical Derivations First Cosmic Velocity From Newton's law for circular orbit: \\[ F_c = F_g \\implies \\frac{mv_1^2}{R} = \\frac{GMm}{R^2} \\Rightarrow v_1 = \\sqrt{\\frac{GM}{R}} \\] Second Cosmic Velocity Energy conservation between surface and infinity: \\[ \\frac{1}{2} m v_2^2 = \\frac{GMm}{R} \\implies v_2 = \\sqrt{\\frac{2GM}{R}} \\] Third Cosmic Velocity The third cosmic velocity combines escape velocity from Earth and Sun. At Earth orbit radius \\(d\\) : \\[ v_{\\text{esc, Sun}} = \\sqrt{\\frac{2GM_{\\odot}}{d}} \\] Earth's orbital speed around Sun: \\[ v_{\\text{orbital}} = \\sqrt{\\frac{GM_{\\odot}}{d}} \\] The spacecraft needs to overcome Sun's gravity from Earth's orbital velocity, thus: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2} = \\sqrt{2GM/R + GM_{\\odot}/d} \\] But practically, third cosmic velocity is often approximated by: \\[ v_3 \\approx 42.1 \\text{ km/s} \\quad \\text{(from Earth)} \\] 4. Parameters Affecting Cosmic Velocities Mass \\(M\\) and radius \\(R\\) of celestial bodies influence first and second cosmic velocities. Distance \\(d\\) from star influences the third cosmic velocity. For gas giants like Jupiter with large \\(M\\) and \\(R\\) , escape velocities are much higher. Atmospheres, rotation, and shape irregularities can modify these values in practice. 5. Calculations and Visualization for Earth, Mars, Jupiter Physical constants and data Planet Mass (kg) Radius (m) Surface Gravity (m/s\u00b2) Earth \\(5.97 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) 9.81 Mars \\(6.39 \\times 10^{23}\\) \\(3.39 \\times 10^6\\) 3.71 Jupiter \\(1.90 \\times 10^{27}\\) \\(6.99 \\times 10^7\\) 24.79 Sun\u2019s mass \\(M_{\\odot} = 1.989 \\times 10^{30}\\) kg, Earth-Sun distance \\(d = 1.496 \\times 10^{11}\\) m. 6. Python Implementation with 3D Plots We'll plot the first and second cosmic velocities as a function of radius and mass, and illustrate third cosmic velocity at Earth's orbit. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Gravitational constant G = 6.67430e-11 # Define ranges for mass (kg) and radius (m) for hypothetical planets mass_range = np.linspace(1e23, 2e27, 100) # 1e23 to 2e27 kg radius_range = np.linspace(1e6, 8e7, 100) # 1e6 to 8e7 meters Mass, Radius = np.meshgrid(mass_range, radius_range) # First cosmic velocity v1 = np.sqrt(G * Mass / Radius) # Second cosmic velocity (escape velocity) v2 = np.sqrt(2) * v1 # 3D Plot for First Cosmic Velocity fig = plt.figure(figsize=(14, 6)) ax1 = fig.add_subplot(121, projection='3d') surf1 = ax1.plot_surface(Mass, Radius, v1 / 1e3, cmap='viridis') # km/s ax1.set_title('First Cosmic Velocity (Orbital Velocity) [km/s]') ax1.set_xlabel('Mass (kg)') ax1.set_ylabel('Radius (m)') ax1.set_zlabel('Velocity (km/s)') fig.colorbar(surf1, ax=ax1, shrink=0.5, aspect=5) # 3D Plot for Second Cosmic Velocity ax2 = fig.add_subplot(122, projection='3d') surf2 = ax2.plot_surface(Mass, Radius, v2 / 1e3, cmap='inferno') # km/s ax2.set_title('Second Cosmic Velocity (Escape Velocity) [km/s]') ax2.set_xlabel('Mass (kg)') ax2.set_ylabel('Radius (m)') ax2.set_zlabel('Velocity (km/s)') fig.colorbar(surf2, ax=ax2, shrink=0.5, aspect=5) plt.tight_layout() plt.show() Calculating cosmic velocities for Earth, Mars, Jupiter # Planet data planets = { 'Earth': {'M': 5.97e24, 'R': 6.371e6}, 'Mars': {'M': 6.39e23, 'R': 3.39e6}, 'Jupiter': {'M': 1.90e27, 'R': 6.99e7} } for name, data in planets.items(): v1 = np.sqrt(G * data['M'] / data['R']) v2 = np.sqrt(2) * v1 print(f\"{name}:\\n First Cosmic Velocity (v1): {v1/1e3:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {v2/1e3:.2f} km/s\\n\") # Third cosmic velocity from Earth (escaping Sun) M_sun = 1.989e30 d_earth_sun = 1.496e11 v_esc_sun = np.sqrt(2 * G * M_sun / d_earth_sun) # Escape from Sun at Earth orbit v_orbital_earth = np.sqrt(G * M_sun / d_earth_sun) v3 = np.sqrt(v_esc_sun**2 + v_orbital_earth**2) print(f\"Third Cosmic Velocity (Earth escaping Sun): {v3/1e3:.2f} km/s\") Earth: First Cosmic Velocity (v1): 7.91 km/s Second Cosmic Velocity (v2): 11.18 km/s Mars: First Cosmic Velocity (v1): 3.55 km/s Second Cosmic Velocity (v2): 5.02 km/s Jupiter: First Cosmic Velocity (v1): 42.59 km/s Second Cosmic Velocity (v2): 60.24 km/s Third Cosmic Velocity (Earth escaping Sun): 51.60 km/s 7. Importance in Space Exploration Launching Satellites: Must reach at least first cosmic velocity to maintain orbit. Leaving Earth: Rockets must achieve or exceed escape velocity. Interplanetary Travel: Escaping Earth\u2019s gravity and entering transfer orbits (third cosmic velocity) critical for missions to other planets. Interstellar Missions: Third cosmic velocity sets baseline for leaving star systems. 8. Summary Defined and derived first, second, and third cosmic velocities. Illustrated how mass and radius influence these velocities. Computed velocities for Earth, Mars, Jupiter, and Sun-Earth system. Created 3D visualizations to explore velocity dependencies. Discussed critical role of cosmic velocities in space mission design.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-introduction-and-motivation","text":"The concept of escape velocity is fundamental in astrophysics and space exploration. It determines the minimum speed needed for an object to break free from the gravitational pull of a celestial body without additional propulsion. Building on escape velocity, the first , second , and third cosmic velocities represent important speed thresholds for different kinds of motion relative to planets and stars: First cosmic velocity : speed to maintain a stable circular orbit just above a planet\u2019s surface. Second cosmic velocity (escape velocity) : speed to leave a planet\u2019s gravitational field. Third cosmic velocity : speed needed to escape the gravitational pull of the entire star system (e.g., the Sun\u2019s gravity for Earth). These velocities guide the design of satellites, interplanetary spacecraft, and concepts for interstellar travel.","title":"1. Introduction and Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-definitions-and-physical-meaning","text":"","title":"2. Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity","text":"Also called orbital velocity at the surface. Minimum horizontal speed to orbit a planet in a circular path close to the surface. \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] where: \\(G\\) is gravitational constant, \\(M\\) is mass of the planet, \\(R\\) is radius of the planet.","title":"First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"Minimum speed to escape the gravitational field without further propulsion. \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} v_1 \\] This velocity comes from conservation of energy, where kinetic energy equals gravitational potential energy.","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"Speed to escape the gravitational field of the star system (e.g., escape Sun\u2019s gravity from Earth\u2019s orbit). For Earth escaping Sun\u2019s gravity: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2} = \\sqrt{2GM_{\\odot}/d} + v_{\\text{orbital}}^2 \\] More precisely, the speed required at Earth's orbit to leave the Sun\u2019s influence, where \\(M_{\\odot}\\) = mass of the Sun, \\(d\\) = Earth-Sun distance, \\(v_{\\text{orbital}}\\) = Earth\u2019s orbital velocity around the Sun.","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-mathematical-derivations","text":"","title":"3. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity_1","text":"From Newton's law for circular orbit: \\[ F_c = F_g \\implies \\frac{mv_1^2}{R} = \\frac{GMm}{R^2} \\Rightarrow v_1 = \\sqrt{\\frac{GM}{R}} \\]","title":"First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity","text":"Energy conservation between surface and infinity: \\[ \\frac{1}{2} m v_2^2 = \\frac{GMm}{R} \\implies v_2 = \\sqrt{\\frac{2GM}{R}} \\]","title":"Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity_1","text":"The third cosmic velocity combines escape velocity from Earth and Sun. At Earth orbit radius \\(d\\) : \\[ v_{\\text{esc, Sun}} = \\sqrt{\\frac{2GM_{\\odot}}{d}} \\] Earth's orbital speed around Sun: \\[ v_{\\text{orbital}} = \\sqrt{\\frac{GM_{\\odot}}{d}} \\] The spacecraft needs to overcome Sun's gravity from Earth's orbital velocity, thus: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{orbital}}^2} = \\sqrt{2GM/R + GM_{\\odot}/d} \\] But practically, third cosmic velocity is often approximated by: \\[ v_3 \\approx 42.1 \\text{ km/s} \\quad \\text{(from Earth)} \\]","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-parameters-affecting-cosmic-velocities","text":"Mass \\(M\\) and radius \\(R\\) of celestial bodies influence first and second cosmic velocities. Distance \\(d\\) from star influences the third cosmic velocity. For gas giants like Jupiter with large \\(M\\) and \\(R\\) , escape velocities are much higher. Atmospheres, rotation, and shape irregularities can modify these values in practice.","title":"4. Parameters Affecting Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-calculations-and-visualization-for-earth-mars-jupiter","text":"","title":"5. Calculations and Visualization for Earth, Mars, Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#physical-constants-and-data","text":"Planet Mass (kg) Radius (m) Surface Gravity (m/s\u00b2) Earth \\(5.97 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) 9.81 Mars \\(6.39 \\times 10^{23}\\) \\(3.39 \\times 10^6\\) 3.71 Jupiter \\(1.90 \\times 10^{27}\\) \\(6.99 \\times 10^7\\) 24.79 Sun\u2019s mass \\(M_{\\odot} = 1.989 \\times 10^{30}\\) kg, Earth-Sun distance \\(d = 1.496 \\times 10^{11}\\) m.","title":"Physical constants and data"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-python-implementation-with-3d-plots","text":"We'll plot the first and second cosmic velocities as a function of radius and mass, and illustrate third cosmic velocity at Earth's orbit. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Gravitational constant G = 6.67430e-11 # Define ranges for mass (kg) and radius (m) for hypothetical planets mass_range = np.linspace(1e23, 2e27, 100) # 1e23 to 2e27 kg radius_range = np.linspace(1e6, 8e7, 100) # 1e6 to 8e7 meters Mass, Radius = np.meshgrid(mass_range, radius_range) # First cosmic velocity v1 = np.sqrt(G * Mass / Radius) # Second cosmic velocity (escape velocity) v2 = np.sqrt(2) * v1 # 3D Plot for First Cosmic Velocity fig = plt.figure(figsize=(14, 6)) ax1 = fig.add_subplot(121, projection='3d') surf1 = ax1.plot_surface(Mass, Radius, v1 / 1e3, cmap='viridis') # km/s ax1.set_title('First Cosmic Velocity (Orbital Velocity) [km/s]') ax1.set_xlabel('Mass (kg)') ax1.set_ylabel('Radius (m)') ax1.set_zlabel('Velocity (km/s)') fig.colorbar(surf1, ax=ax1, shrink=0.5, aspect=5) # 3D Plot for Second Cosmic Velocity ax2 = fig.add_subplot(122, projection='3d') surf2 = ax2.plot_surface(Mass, Radius, v2 / 1e3, cmap='inferno') # km/s ax2.set_title('Second Cosmic Velocity (Escape Velocity) [km/s]') ax2.set_xlabel('Mass (kg)') ax2.set_ylabel('Radius (m)') ax2.set_zlabel('Velocity (km/s)') fig.colorbar(surf2, ax=ax2, shrink=0.5, aspect=5) plt.tight_layout() plt.show()","title":"6. Python Implementation with 3D Plots"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculating-cosmic-velocities-for-earth-mars-jupiter","text":"# Planet data planets = { 'Earth': {'M': 5.97e24, 'R': 6.371e6}, 'Mars': {'M': 6.39e23, 'R': 3.39e6}, 'Jupiter': {'M': 1.90e27, 'R': 6.99e7} } for name, data in planets.items(): v1 = np.sqrt(G * data['M'] / data['R']) v2 = np.sqrt(2) * v1 print(f\"{name}:\\n First Cosmic Velocity (v1): {v1/1e3:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {v2/1e3:.2f} km/s\\n\") # Third cosmic velocity from Earth (escaping Sun) M_sun = 1.989e30 d_earth_sun = 1.496e11 v_esc_sun = np.sqrt(2 * G * M_sun / d_earth_sun) # Escape from Sun at Earth orbit v_orbital_earth = np.sqrt(G * M_sun / d_earth_sun) v3 = np.sqrt(v_esc_sun**2 + v_orbital_earth**2) print(f\"Third Cosmic Velocity (Earth escaping Sun): {v3/1e3:.2f} km/s\") Earth: First Cosmic Velocity (v1): 7.91 km/s Second Cosmic Velocity (v2): 11.18 km/s Mars: First Cosmic Velocity (v1): 3.55 km/s Second Cosmic Velocity (v2): 5.02 km/s Jupiter: First Cosmic Velocity (v1): 42.59 km/s Second Cosmic Velocity (v2): 60.24 km/s Third Cosmic Velocity (Earth escaping Sun): 51.60 km/s","title":"Calculating cosmic velocities for Earth, Mars, Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#7-importance-in-space-exploration","text":"Launching Satellites: Must reach at least first cosmic velocity to maintain orbit. Leaving Earth: Rockets must achieve or exceed escape velocity. Interplanetary Travel: Escaping Earth\u2019s gravity and entering transfer orbits (third cosmic velocity) critical for missions to other planets. Interstellar Missions: Third cosmic velocity sets baseline for leaving star systems.","title":"7. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#8-summary","text":"Defined and derived first, second, and third cosmic velocities. Illustrated how mass and radius influence these velocities. Computed velocities for Earth, Mars, Jupiter, and Sun-Earth system. Created 3D visualizations to explore velocity dependencies. Discussed critical role of cosmic velocities in space mission design.","title":"8. Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth 1. Introduction and Motivation When a payload is released from a moving rocket near Earth, its subsequent path depends on its initial position, velocity, and the gravitational pull of Earth. The possible trajectories include: Elliptical orbits (including circular), Parabolic trajectories (escape at exactly escape velocity), Hyperbolic trajectories (escape with velocity greater than escape velocity), Suborbital (ballistic) trajectories leading to reentry. Understanding these paths is crucial for: Satellite deployment, Controlled reentry of space vehicles, Planning interplanetary missions. 2. Theoretical Background Newton\u2019s Law of Universal Gravitation The gravitational acceleration experienced by the payload at position \\(\\mathbf{r}\\) relative to Earth's center is: \\[ \\mathbf{a} = -\\frac{GM}{|\\mathbf{r}|^3} \\mathbf{r} \\] where: \\(G\\) = gravitational constant, \\(M\\) = mass of Earth, \\(\\mathbf{r}\\) = position vector of the payload relative to Earth\u2019s center. Orbital Energy and Trajectory Types Total specific mechanical energy \\(\\varepsilon\\) of the payload (per unit mass) determines trajectory type: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] \\(\\varepsilon < 0\\) : Elliptical orbit (closed), \\(\\varepsilon = 0\\) : Parabolic trajectory (critical escape), \\(\\varepsilon > 0\\) : Hyperbolic trajectory (unbound escape). Orbital Elements (Optional) From initial \\(\\mathbf{r}\\) and velocity \\(\\mathbf{v}\\) , orbital parameters such as semi-major axis, eccentricity, and inclination can be derived, but for simulation we focus on trajectory integration. 3. Numerical Simulation Approach Equations of Motion (2D simplification) We model the payload\u2019s motion in the plane: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] \\[ \\frac{d\\mathbf{v}}{dt} = - \\frac{GM}{r^3} \\mathbf{r} \\] Numerical Integration Method Use numerical ODE solvers like Runge-Kutta (RK4 or RK45) to integrate position and velocity over time, given initial conditions: Initial position vector \\(\\mathbf{r}_0\\) , Initial velocity vector \\(\\mathbf{v}_0\\) . 4. Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_earth = 5.972e24 # kg R_earth = 6.371e6 # m def gravity_ode(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y_pos / r**3 return [vx, vy, ax, ay] def simulate_trajectory(r0, v0, t_span, max_step=1): y0 = [r0[0], r0[1], v0[0], v0[1]] sol = solve_ivp(gravity_ode, t_span, y0, max_step=max_step, rtol=1e-8, atol=1e-8) return sol # Example Initial Conditions: # Payload released 300 km above Earth surface (circular orbit altitude) altitude = 300e3 # 300 km r0_mag = R_earth + altitude r0 = np.array([r0_mag, 0]) # Starting on x-axis # Circular orbital velocity at altitude: v_circ = np.sqrt(G * M_earth / r0_mag) v0_circular = np.array([0, v_circ]) # Velocity perpendicular to radius vector # Slightly less velocity for suborbital trajectory (will reenter) v0_suborbital = v0_circular * 0.9 # Greater than escape velocity for hyperbolic trajectory v_escape = np.sqrt(2 * G * M_earth / r0_mag) v0_escape = np.array([0, v_escape * 1.1]) # Simulate all three cases t_span = (0, 6000) # seconds (about 1.7 hours) sol_circular = simulate_trajectory(r0, v0_circular, t_span) sol_suborbital = simulate_trajectory(r0, v0_suborbital, t_span) sol_escape = simulate_trajectory(r0, v0_escape, t_span) # Plot trajectories plt.figure(figsize=(10,10)) # Earth for reference earth = plt.Circle((0,0), R_earth, color='blue', alpha=0.3) plt.gca().add_artist(earth) plt.plot(sol_circular.y[0], sol_circular.y[1], label='Circular Orbit') plt.plot(sol_suborbital.y[0], sol_suborbital.y[1], label='Suborbital (Reentry)') plt.plot(sol_escape.y[0], sol_escape.y[1], label='Escape Trajectory') plt.scatter([r0[0]], [r0[1]], color='black', label='Release Point') plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Payload Trajectories near Earth') plt.legend() plt.axis('equal') plt.grid(True) plt.show() 5. Explanation of Results Circular Orbit: The payload velocity matches the circular orbital velocity, maintaining a stable orbit. Suborbital: Velocity is insufficient to stay in orbit; the payload follows a ballistic trajectory and reenters the atmosphere. Escape Trajectory: Velocity exceeds escape velocity; the payload follows a hyperbolic path, leaving Earth\u2019s gravitational influence. 6. Applications Satellite Deployment: Ensuring the payload reaches appropriate orbit velocity. Reentry Vehicles: Planning controlled descent paths. Interplanetary Missions: Releasing payloads at escape velocity to begin transfer orbits. 7. Extensions and Further Work 3D Trajectory Simulation: Include inclination and full 3D vector initial conditions. Atmospheric Drag: Add drag forces for realistic reentry simulation. Non-uniform Gravity: Model Earth\u2019s oblateness or gravitational anomalies. Multi-body Effects: Consider Moon and Sun gravity influences. 8. Summary Derived motion equations for a payload near Earth. Explained trajectory types via total energy. Developed a Python simulation of orbital, suborbital, and escape trajectories. Visualized the different paths, highlighting mission-relevant cases.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-introduction-and-motivation","text":"When a payload is released from a moving rocket near Earth, its subsequent path depends on its initial position, velocity, and the gravitational pull of Earth. The possible trajectories include: Elliptical orbits (including circular), Parabolic trajectories (escape at exactly escape velocity), Hyperbolic trajectories (escape with velocity greater than escape velocity), Suborbital (ballistic) trajectories leading to reentry. Understanding these paths is crucial for: Satellite deployment, Controlled reentry of space vehicles, Planning interplanetary missions.","title":"1. Introduction and Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-theoretical-background","text":"","title":"2. Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-universal-gravitation","text":"The gravitational acceleration experienced by the payload at position \\(\\mathbf{r}\\) relative to Earth's center is: \\[ \\mathbf{a} = -\\frac{GM}{|\\mathbf{r}|^3} \\mathbf{r} \\] where: \\(G\\) = gravitational constant, \\(M\\) = mass of Earth, \\(\\mathbf{r}\\) = position vector of the payload relative to Earth\u2019s center.","title":"Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-energy-and-trajectory-types","text":"Total specific mechanical energy \\(\\varepsilon\\) of the payload (per unit mass) determines trajectory type: \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] \\(\\varepsilon < 0\\) : Elliptical orbit (closed), \\(\\varepsilon = 0\\) : Parabolic trajectory (critical escape), \\(\\varepsilon > 0\\) : Hyperbolic trajectory (unbound escape).","title":"Orbital Energy and Trajectory Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-elements-optional","text":"From initial \\(\\mathbf{r}\\) and velocity \\(\\mathbf{v}\\) , orbital parameters such as semi-major axis, eccentricity, and inclination can be derived, but for simulation we focus on trajectory integration.","title":"Orbital Elements (Optional)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-numerical-simulation-approach","text":"","title":"3. Numerical Simulation Approach"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion-2d-simplification","text":"We model the payload\u2019s motion in the plane: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] \\[ \\frac{d\\mathbf{v}}{dt} = - \\frac{GM}{r^3} \\mathbf{r} \\]","title":"Equations of Motion (2D simplification)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-integration-method","text":"Use numerical ODE solvers like Runge-Kutta (RK4 or RK45) to integrate position and velocity over time, given initial conditions: Initial position vector \\(\\mathbf{r}_0\\) , Initial velocity vector \\(\\mathbf{v}_0\\) .","title":"Numerical Integration Method"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_earth = 5.972e24 # kg R_earth = 6.371e6 # m def gravity_ode(t, y): x, y_pos, vx, vy = y r = np.sqrt(x**2 + y_pos**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y_pos / r**3 return [vx, vy, ax, ay] def simulate_trajectory(r0, v0, t_span, max_step=1): y0 = [r0[0], r0[1], v0[0], v0[1]] sol = solve_ivp(gravity_ode, t_span, y0, max_step=max_step, rtol=1e-8, atol=1e-8) return sol # Example Initial Conditions: # Payload released 300 km above Earth surface (circular orbit altitude) altitude = 300e3 # 300 km r0_mag = R_earth + altitude r0 = np.array([r0_mag, 0]) # Starting on x-axis # Circular orbital velocity at altitude: v_circ = np.sqrt(G * M_earth / r0_mag) v0_circular = np.array([0, v_circ]) # Velocity perpendicular to radius vector # Slightly less velocity for suborbital trajectory (will reenter) v0_suborbital = v0_circular * 0.9 # Greater than escape velocity for hyperbolic trajectory v_escape = np.sqrt(2 * G * M_earth / r0_mag) v0_escape = np.array([0, v_escape * 1.1]) # Simulate all three cases t_span = (0, 6000) # seconds (about 1.7 hours) sol_circular = simulate_trajectory(r0, v0_circular, t_span) sol_suborbital = simulate_trajectory(r0, v0_suborbital, t_span) sol_escape = simulate_trajectory(r0, v0_escape, t_span) # Plot trajectories plt.figure(figsize=(10,10)) # Earth for reference earth = plt.Circle((0,0), R_earth, color='blue', alpha=0.3) plt.gca().add_artist(earth) plt.plot(sol_circular.y[0], sol_circular.y[1], label='Circular Orbit') plt.plot(sol_suborbital.y[0], sol_suborbital.y[1], label='Suborbital (Reentry)') plt.plot(sol_escape.y[0], sol_escape.y[1], label='Escape Trajectory') plt.scatter([r0[0]], [r0[1]], color='black', label='Release Point') plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Payload Trajectories near Earth') plt.legend() plt.axis('equal') plt.grid(True) plt.show()","title":"4. Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-explanation-of-results","text":"Circular Orbit: The payload velocity matches the circular orbital velocity, maintaining a stable orbit. Suborbital: Velocity is insufficient to stay in orbit; the payload follows a ballistic trajectory and reenters the atmosphere. Escape Trajectory: Velocity exceeds escape velocity; the payload follows a hyperbolic path, leaving Earth\u2019s gravitational influence.","title":"5. Explanation of Results"},{"location":"1%20Physics/2%20Gravity/Problem_3/#6-applications","text":"Satellite Deployment: Ensuring the payload reaches appropriate orbit velocity. Reentry Vehicles: Planning controlled descent paths. Interplanetary Missions: Releasing payloads at escape velocity to begin transfer orbits.","title":"6. Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#7-extensions-and-further-work","text":"3D Trajectory Simulation: Include inclination and full 3D vector initial conditions. Atmospheric Drag: Add drag forces for realistic reentry simulation. Non-uniform Gravity: Model Earth\u2019s oblateness or gravitational anomalies. Multi-body Effects: Consider Moon and Sun gravity influences.","title":"7. Extensions and Further Work"},{"location":"1%20Physics/2%20Gravity/Problem_3/#8-summary","text":"Derived motion equations for a payload near Earth. Explained trajectory types via total energy. Developed a Python simulation of orbital, suborbital, and escape trajectories. Visualized the different paths, highlighting mission-relevant cases.","title":"8. Summary"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Wave Interference Patterns 1. Theoretical Background 1.1 Wave from a Point Source Each point source located at \\((x_0, y_0)\\) emits a circular wave on the water surface described by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(k r - \\omega t + \\phi) \\] where: \\(A\\) is the amplitude, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega = 2\\pi f\\) is the angular frequency, \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source to point \\((x,y)\\) , \\(\\phi\\) is the initial phase. The \\(1/\\sqrt{r}\\) term models the wave amplitude decay with distance, typical for cylindrical waves. 1.2 Superposition Principle When multiple sources emit waves simultaneously, the resulting displacement at a point is the sum of all individual displacements: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) \\] where \\(N\\) is the number of sources, and each \\(r_i\\) is the distance from the \\(i\\) -th source. 1.3 Regular Polygon Source Arrangement The point sources are placed at the vertices of a regular polygon inscribed in a circle of radius \\(R\\) . The vertices coordinates are: \\[ x_i = R \\cos\\left(\\theta_i\\right), \\quad y_i = R \\sin\\left(\\theta_i\\right) \\] with \\[ \\theta_i = \\frac{2\\pi i}{N}, \\quad i = 0, 1, ..., N-1 \\] 2. Numerical Simulation & Visualization We will use Python with libraries: NumPy : for efficient numerical calculations. Matplotlib : for 2D and 3D plotting. Matplotlib.animation : for creating animated time evolution of interference. 2.1 Simulation Code with Extended Features import numpy as np import matplotlib.pyplot as plt from matplotlib import cm from matplotlib.animation import FuncAnimation # Parameters N = 6 # Number of vertices (hexagon example) R = 5.0 # Radius of polygon circle A = 1.0 # Amplitude wavelength = 2.0 # Wavelength \u03bb k = 2 * np.pi / wavelength # Wave number f = 0.5 # Frequency (Hz) omega = 2 * np.pi * f # Angular frequency phi = 0 # Initial phase # Generate source points coordinates angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources_x = R * np.cos(angles) sources_y = R * np.sin(angles) # Observation grid grid_size = 300 x = np.linspace(-10, 10, grid_size) y = np.linspace(-10, 10, grid_size) X, Y = np.meshgrid(x, y) def wave_displacement(X, Y, t): \"\"\"Calculate superposed wave displacement at time t.\"\"\" eta_sum = np.zeros_like(X) for x0, y0 in zip(sources_x, sources_y): r = np.sqrt((X - x0)**2 + (Y - y0)**2) r[r == 0] = 1e-6 # Avoid division by zero at source eta_sum += A / np.sqrt(r) * np.cos(k * r - omega * t + phi) return eta_sum # Plot 3D surface at fixed time t fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') t = 0 # Time snapshot Z = wave_displacement(X, Y, t) # 3D surface plot surf = ax.plot_surface(X, Y, Z, cmap=cm.viridis, edgecolor='none') ax.set_title(f'3D Interference Pattern at t={t:.2f}s\\n{N}-sided Polygon Wave Sources') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Displacement \u03b7') fig.colorbar(surf, shrink=0.5, aspect=10, label='Wave Displacement') plt.show() 2.2 Explanation of the 3D Plot The height (z-axis) represents the wave displacement at each \\((x,y)\\) point on the water surface. Peaks correspond to constructive interference , valleys to destructive interference . The shape of the interference pattern is heavily influenced by the polygon shape (number of sources and radius). The sources themselves are located on the circle's perimeter and are not explicitly marked here but can be added. 2.3 Animated Wave Interference Over Time Visualizing how the pattern evolves over time helps understand wave propagation and phase effects. fig, ax = plt.subplots(figsize=(8,8)) # Initialize the plot with zeros Z = wave_displacement(X, Y, 0) im = ax.imshow(Z, extent=[-10,10,-10,10], cmap='RdBu', vmin=-2*A, vmax=2*A) ax.set_title(f'Wave Interference Pattern at t=0.00s') ax.set_xlabel('x') ax.set_ylabel('y') # Plot source points ax.scatter(sources_x, sources_y, color='black', s=50, label='Sources') ax.legend() def update(frame): t = frame / 30 # time in seconds Z = wave_displacement(X, Y, t) im.set_data(Z) ax.set_title(f'Wave Interference Pattern at t={t:.2f}s') return [im] ani = FuncAnimation(fig, update, frames=120, interval=50, blit=True) plt.show() 2.4 Advanced Visualization: Interference Intensity Map Plotting the square of the displacement ( \\(\\eta^2\\) ) highlights energy and intensity, emphasizing constructive regions more clearly. Z_intensity = wave_displacement(X, Y, 0)**2 plt.figure(figsize=(8,8)) plt.title(f'Interference Intensity Map at t=0s') plt.xlabel('x') plt.ylabel('y') plt.pcolormesh(X, Y, Z_intensity, shading='auto', cmap='inferno') plt.colorbar(label='Intensity (Displacement\u00b2)') plt.scatter(sources_x, sources_y, color='white', marker='*', s=100, label='Sources') plt.legend() plt.axis('equal') plt.show() 3. Analysis of Interference Patterns Number of sources \\(N\\) : Increasing \\(N\\) increases the complexity, producing intricate interference fringes. Polygon radius \\(R\\) : Larger \\(R\\) means sources are spaced farther, changing fringe spacing. Wavelength \\(\\lambda\\) : Controls fringe spacing; larger wavelength means wider fringes. Frequency and time \\(t\\) : The pattern oscillates over time. Snapshots at different times show the dynamic nature. Amplitude decay \\(1/\\sqrt{r}\\) : Reduces amplitude with distance, realistic for circular waves. Constructive interference: Occurs where phase differences between waves are multiples of \\(2\\pi\\) , causing wave peaks to align, amplifying displacement. Destructive interference: Occurs where phase differences are odd multiples of \\(\\pi\\) , causing peaks of one wave to align with troughs of another, cancelling displacement. 4. Deliverables Summary Deliverable Description Markdown document Full theoretical explanation + results discussion Python code Includes regular polygon setup, wave displacement calculation, and plotting (2D, 3D, animation) Graphical outputs Static 3D plots, animated 2D interference, intensity maps Analysis Interpretation of patterns, influence of parameters 5. Optional Extensions for Further Study Allow varying initial phase \\(\\phi_i\\) per source to study phase-shifted sources. Include damping effects to simulate wave energy loss over time. Animate 3D surface plots over time using mpl_toolkits.mplot3d animations. Interactive widgets (e.g., with ipywidgets ) to control parameters like \\(N\\) , \\(R\\) , \\(\\lambda\\) , and \\(t\\) live.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference-patterns","text":"","title":"Wave Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theoretical-background","text":"","title":"1. Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#11-wave-from-a-point-source","text":"Each point source located at \\((x_0, y_0)\\) emits a circular wave on the water surface described by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(k r - \\omega t + \\phi) \\] where: \\(A\\) is the amplitude, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega = 2\\pi f\\) is the angular frequency, \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source to point \\((x,y)\\) , \\(\\phi\\) is the initial phase. The \\(1/\\sqrt{r}\\) term models the wave amplitude decay with distance, typical for cylindrical waves.","title":"1.1 Wave from a Point Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#12-superposition-principle","text":"When multiple sources emit waves simultaneously, the resulting displacement at a point is the sum of all individual displacements: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) \\] where \\(N\\) is the number of sources, and each \\(r_i\\) is the distance from the \\(i\\) -th source.","title":"1.2 Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#13-regular-polygon-source-arrangement","text":"The point sources are placed at the vertices of a regular polygon inscribed in a circle of radius \\(R\\) . The vertices coordinates are: \\[ x_i = R \\cos\\left(\\theta_i\\right), \\quad y_i = R \\sin\\left(\\theta_i\\right) \\] with \\[ \\theta_i = \\frac{2\\pi i}{N}, \\quad i = 0, 1, ..., N-1 \\]","title":"1.3 Regular Polygon Source Arrangement"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-numerical-simulation-visualization","text":"We will use Python with libraries: NumPy : for efficient numerical calculations. Matplotlib : for 2D and 3D plotting. Matplotlib.animation : for creating animated time evolution of interference.","title":"2. Numerical Simulation &amp; Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#21-simulation-code-with-extended-features","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib import cm from matplotlib.animation import FuncAnimation # Parameters N = 6 # Number of vertices (hexagon example) R = 5.0 # Radius of polygon circle A = 1.0 # Amplitude wavelength = 2.0 # Wavelength \u03bb k = 2 * np.pi / wavelength # Wave number f = 0.5 # Frequency (Hz) omega = 2 * np.pi * f # Angular frequency phi = 0 # Initial phase # Generate source points coordinates angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources_x = R * np.cos(angles) sources_y = R * np.sin(angles) # Observation grid grid_size = 300 x = np.linspace(-10, 10, grid_size) y = np.linspace(-10, 10, grid_size) X, Y = np.meshgrid(x, y) def wave_displacement(X, Y, t): \"\"\"Calculate superposed wave displacement at time t.\"\"\" eta_sum = np.zeros_like(X) for x0, y0 in zip(sources_x, sources_y): r = np.sqrt((X - x0)**2 + (Y - y0)**2) r[r == 0] = 1e-6 # Avoid division by zero at source eta_sum += A / np.sqrt(r) * np.cos(k * r - omega * t + phi) return eta_sum # Plot 3D surface at fixed time t fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') t = 0 # Time snapshot Z = wave_displacement(X, Y, t) # 3D surface plot surf = ax.plot_surface(X, Y, Z, cmap=cm.viridis, edgecolor='none') ax.set_title(f'3D Interference Pattern at t={t:.2f}s\\n{N}-sided Polygon Wave Sources') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Displacement \u03b7') fig.colorbar(surf, shrink=0.5, aspect=10, label='Wave Displacement') plt.show()","title":"2.1 Simulation Code with Extended Features"},{"location":"1%20Physics/3%20Waves/Problem_1/#22-explanation-of-the-3d-plot","text":"The height (z-axis) represents the wave displacement at each \\((x,y)\\) point on the water surface. Peaks correspond to constructive interference , valleys to destructive interference . The shape of the interference pattern is heavily influenced by the polygon shape (number of sources and radius). The sources themselves are located on the circle's perimeter and are not explicitly marked here but can be added.","title":"2.2 Explanation of the 3D Plot"},{"location":"1%20Physics/3%20Waves/Problem_1/#23-animated-wave-interference-over-time","text":"Visualizing how the pattern evolves over time helps understand wave propagation and phase effects. fig, ax = plt.subplots(figsize=(8,8)) # Initialize the plot with zeros Z = wave_displacement(X, Y, 0) im = ax.imshow(Z, extent=[-10,10,-10,10], cmap='RdBu', vmin=-2*A, vmax=2*A) ax.set_title(f'Wave Interference Pattern at t=0.00s') ax.set_xlabel('x') ax.set_ylabel('y') # Plot source points ax.scatter(sources_x, sources_y, color='black', s=50, label='Sources') ax.legend() def update(frame): t = frame / 30 # time in seconds Z = wave_displacement(X, Y, t) im.set_data(Z) ax.set_title(f'Wave Interference Pattern at t={t:.2f}s') return [im] ani = FuncAnimation(fig, update, frames=120, interval=50, blit=True) plt.show()","title":"2.3 Animated Wave Interference Over Time"},{"location":"1%20Physics/3%20Waves/Problem_1/#24-advanced-visualization-interference-intensity-map","text":"Plotting the square of the displacement ( \\(\\eta^2\\) ) highlights energy and intensity, emphasizing constructive regions more clearly. Z_intensity = wave_displacement(X, Y, 0)**2 plt.figure(figsize=(8,8)) plt.title(f'Interference Intensity Map at t=0s') plt.xlabel('x') plt.ylabel('y') plt.pcolormesh(X, Y, Z_intensity, shading='auto', cmap='inferno') plt.colorbar(label='Intensity (Displacement\u00b2)') plt.scatter(sources_x, sources_y, color='white', marker='*', s=100, label='Sources') plt.legend() plt.axis('equal') plt.show()","title":"2.4 Advanced Visualization: Interference Intensity Map"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-analysis-of-interference-patterns","text":"Number of sources \\(N\\) : Increasing \\(N\\) increases the complexity, producing intricate interference fringes. Polygon radius \\(R\\) : Larger \\(R\\) means sources are spaced farther, changing fringe spacing. Wavelength \\(\\lambda\\) : Controls fringe spacing; larger wavelength means wider fringes. Frequency and time \\(t\\) : The pattern oscillates over time. Snapshots at different times show the dynamic nature. Amplitude decay \\(1/\\sqrt{r}\\) : Reduces amplitude with distance, realistic for circular waves.","title":"3. Analysis of Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-interference","text":"Occurs where phase differences between waves are multiples of \\(2\\pi\\) , causing wave peaks to align, amplifying displacement.","title":"Constructive interference:"},{"location":"1%20Physics/3%20Waves/Problem_1/#destructive-interference","text":"Occurs where phase differences are odd multiples of \\(\\pi\\) , causing peaks of one wave to align with troughs of another, cancelling displacement.","title":"Destructive interference:"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-deliverables-summary","text":"Deliverable Description Markdown document Full theoretical explanation + results discussion Python code Includes regular polygon setup, wave displacement calculation, and plotting (2D, 3D, animation) Graphical outputs Static 3D plots, animated 2D interference, intensity maps Analysis Interpretation of patterns, influence of parameters","title":"4. Deliverables Summary"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-optional-extensions-for-further-study","text":"Allow varying initial phase \\(\\phi_i\\) per source to study phase-shifted sources. Include damping effects to simulate wave energy loss over time. Animate 3D surface plots over time using mpl_toolkits.mplot3d animations. Interactive widgets (e.g., with ipywidgets ) to control parameters like \\(N\\) , \\(R\\) , \\(\\lambda\\) , and \\(t\\) live.","title":"5. Optional Extensions for Further Study"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force on a Charged Particle \u2014 Extended Version Introduction and Physical Background The Lorentz force \\(\\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B}\\) is fundamental for describing how charged particles behave in electromagnetic fields. This principle underlies technologies and natural phenomena such as: Particle Accelerators: Particles are accelerated and steered using magnetic and electric fields. Magnetic Confinement Fusion: Plasma particles spiral around magnetic field lines. Space Physics: Charged particles trapped in Earth's magnetosphere follow complex trajectories. Key Physical Concepts Larmor Radius (Gyroradius): Radius of the circular motion of a charged particle in a magnetic field, $$ r_L = \\frac{m v_\\perp}{|q| B} $$ where \\(v_\\perp\\) is the velocity component perpendicular to \\(\\mathbf{B}\\) . Cyclotron Frequency: The angular frequency of gyration around magnetic field lines, $$ \\omega_c = \\frac{|q| B}{m} $$ \\(\\mathbf{E} \\times \\mathbf{B}\\) Drift: When electric and magnetic fields are crossed (perpendicular), particles drift with velocity $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ Numerical Simulation Setup We solve Newton\u2019s second law for the particle under the Lorentz force: \\[ m \\frac{d\\mathbf{v}}{dt} = q\\mathbf{E} + q \\mathbf{v} \\times \\mathbf{B} \\] \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] Python Code Implementation import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D import plotly.graph_objects as go # Physical Constants (proton) q = 1.6e-19 # Coulombs m = 1.67e-27 # kg # Simulation Parameters dt = 1e-9 # seconds num_steps = 15000 def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) def rk4_step(r, v, E, B, dt): \"\"\"Runge-Kutta 4th order integration step for accuracy.\"\"\" def acceleration(vel): return lorentz_force(vel, E, B) / m k1v = acceleration(v) k1r = v k2v = acceleration(v + 0.5 * dt * k1v) k2r = v + 0.5 * dt * k1v k3v = acceleration(v + 0.5 * dt * k2v) k3r = v + 0.5 * dt * k2v k4v = acceleration(v + dt * k3v) k4r = v + dt * k3v v_next = v + (dt / 6) * (k1v + 2*k2v + 2*k3v + k4v) r_next = r + (dt / 6) * (k1r + 2*k2r + 2*k3r + k4r) return r_next, v_next def simulate_motion(r0, v0, E, B, dt=dt, steps=num_steps): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0], v[0] = r0, v0 for i in range(1, steps): r[i], v[i] = rk4_step(r[i-1], v[i-1], E, B, dt) return r, v def calculate_larmor_radius(v, B): \"\"\"Calculate Larmor radius for each velocity vector.\"\"\" v_perp = np.linalg.norm(np.cross(v, B) / np.linalg.norm(B)) B_mag = np.linalg.norm(B) if B_mag == 0: return np.inf return m * v_perp / (np.abs(q) * B_mag) def calculate_drift_velocity(E, B): \"\"\"Calculate E x B drift velocity.\"\"\" B_mag_sq = np.dot(B, B) if B_mag_sq == 0: return np.zeros(3) return np.cross(E, B) / B_mag_sq # Initial Conditions r0 = np.array([0., 0., 0.]) v0 = np.array([1e5, 1e5, 0]) # m/s # Field Configurations # 1) Uniform Magnetic Field (Tesla) B1 = np.array([0, 0, 1]) # 2) Uniform Electric Field parallel to B E2 = np.array([0, 0, 1e3]) # V/m # 3) Crossed E and B fields E3 = np.array([1e3, 0, 0]) # Run simulations for the 3 cases r1, v1 = simulate_motion(r0, v0, np.zeros(3), B1) r2, v2 = simulate_motion(r0, v0, E2, B1) r3, v3 = simulate_motion(r0, v0, E3, B1) # Calculate Larmor radius for case 1 (should be roughly constant) larmor_radius_1 = calculate_larmor_radius(v1[-1], B1) # Calculate drift velocity for crossed fields case drift_velocity = calculate_drift_velocity(E3, B1) print(f\"Larmor radius (final) in uniform B: {larmor_radius_1:.3e} meters\") print(f\"E x B drift velocity in crossed fields: {drift_velocity} m/s\") # Plotting 3D interactive plot for crossed fields case using Plotly fig = go.Figure(data=[go.Scatter3d( x=r3[:,0], y=r3[:,1], z=r3[:,2], mode='lines', line=dict(color='royalblue', width=2) )]) fig.update_layout( title='3D Particle Trajectory in Crossed Electric and Magnetic Fields', scene=dict( xaxis_title='x (m)', yaxis_title='y (m)', zaxis_title='z (m)' ), height=700, width=900 ) fig.show() # Additional Matplotlib plot showing Larmor radius and drift vector overlay plt.figure(figsize=(8,6)) plt.plot(r3[:,0], r3[:,1], label='Trajectory (XY projection)') plt.scatter(r3[-1,0], r3[-1,1], color='red', label='Final position') plt.quiver(0, 0, drift_velocity[0]*1e-6, drift_velocity[1]*1e-6, angles='xy', scale_units='xy', scale=1, color='green', label='E x B drift (scaled)') circle = plt.Circle((r3[-1,0], r3[-1,1]), larmor_radius_1, color='orange', fill=False, label='Larmor radius') plt.gca().add_artist(circle) plt.title('XY Projection with Larmor Radius and E\u00d7B Drift') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.grid(True) plt.legend() plt.show() Detailed Explanation of the Code Runge-Kutta 4th order (RK4): More accurate numerical integration method to solve the coupled differential equations of motion. Larmor Radius Calculation: Computes the radius of gyration to understand the tightness of the particle\u2019s spiral. Drift Velocity Calculation: Quantifies the average velocity perpendicular to both fields. Interactive 3D Plot: Using Plotly to allow zooming, rotating, and exploring the trajectory from all angles. Matplotlib Plot: Overlays Larmor radius and drift velocity vector for intuitive understanding of particle behavior in crossed fields. Physical Interpretation of Outputs The Larmor radius you see indicates the radius of the spiral path of the particle in the uniform magnetic field. The \\(\\mathbf{E} \\times \\mathbf{B}\\) drift velocity vector indicates the net drift of the particle's guiding center perpendicular to both fields. The trajectory in crossed fields is complex, combining gyration and drift \u2014 important in plasma devices and astrophysics. Suggestions for Further Extensions Relativistic Corrections: Modify equations for particles nearing the speed of light. Non-uniform Fields: Add spatial dependence to fields to simulate magnetic mirrors or traps. Collisions: Include effects of particle collisions and scattering. Multiple Particles: Study collective plasma behavior. Animations: Animate the particle trajectory with velocity vectors and field lines for teaching.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force-on-a-charged-particle-extended-version","text":"","title":"Simulating the Effects of the Lorentz Force on a Charged Particle \u2014 Extended Version"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction-and-physical-background","text":"The Lorentz force \\(\\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B}\\) is fundamental for describing how charged particles behave in electromagnetic fields. This principle underlies technologies and natural phenomena such as: Particle Accelerators: Particles are accelerated and steered using magnetic and electric fields. Magnetic Confinement Fusion: Plasma particles spiral around magnetic field lines. Space Physics: Charged particles trapped in Earth's magnetosphere follow complex trajectories.","title":"Introduction and Physical Background"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-physical-concepts","text":"Larmor Radius (Gyroradius): Radius of the circular motion of a charged particle in a magnetic field, $$ r_L = \\frac{m v_\\perp}{|q| B} $$ where \\(v_\\perp\\) is the velocity component perpendicular to \\(\\mathbf{B}\\) . Cyclotron Frequency: The angular frequency of gyration around magnetic field lines, $$ \\omega_c = \\frac{|q| B}{m} $$ \\(\\mathbf{E} \\times \\mathbf{B}\\) Drift: When electric and magnetic fields are crossed (perpendicular), particles drift with velocity $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$","title":"Key Physical Concepts"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#numerical-simulation-setup","text":"We solve Newton\u2019s second law for the particle under the Lorentz force: \\[ m \\frac{d\\mathbf{v}}{dt} = q\\mathbf{E} + q \\mathbf{v} \\times \\mathbf{B} \\] \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\]","title":"Numerical Simulation Setup"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D import plotly.graph_objects as go # Physical Constants (proton) q = 1.6e-19 # Coulombs m = 1.67e-27 # kg # Simulation Parameters dt = 1e-9 # seconds num_steps = 15000 def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) def rk4_step(r, v, E, B, dt): \"\"\"Runge-Kutta 4th order integration step for accuracy.\"\"\" def acceleration(vel): return lorentz_force(vel, E, B) / m k1v = acceleration(v) k1r = v k2v = acceleration(v + 0.5 * dt * k1v) k2r = v + 0.5 * dt * k1v k3v = acceleration(v + 0.5 * dt * k2v) k3r = v + 0.5 * dt * k2v k4v = acceleration(v + dt * k3v) k4r = v + dt * k3v v_next = v + (dt / 6) * (k1v + 2*k2v + 2*k3v + k4v) r_next = r + (dt / 6) * (k1r + 2*k2r + 2*k3r + k4r) return r_next, v_next def simulate_motion(r0, v0, E, B, dt=dt, steps=num_steps): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0], v[0] = r0, v0 for i in range(1, steps): r[i], v[i] = rk4_step(r[i-1], v[i-1], E, B, dt) return r, v def calculate_larmor_radius(v, B): \"\"\"Calculate Larmor radius for each velocity vector.\"\"\" v_perp = np.linalg.norm(np.cross(v, B) / np.linalg.norm(B)) B_mag = np.linalg.norm(B) if B_mag == 0: return np.inf return m * v_perp / (np.abs(q) * B_mag) def calculate_drift_velocity(E, B): \"\"\"Calculate E x B drift velocity.\"\"\" B_mag_sq = np.dot(B, B) if B_mag_sq == 0: return np.zeros(3) return np.cross(E, B) / B_mag_sq # Initial Conditions r0 = np.array([0., 0., 0.]) v0 = np.array([1e5, 1e5, 0]) # m/s # Field Configurations # 1) Uniform Magnetic Field (Tesla) B1 = np.array([0, 0, 1]) # 2) Uniform Electric Field parallel to B E2 = np.array([0, 0, 1e3]) # V/m # 3) Crossed E and B fields E3 = np.array([1e3, 0, 0]) # Run simulations for the 3 cases r1, v1 = simulate_motion(r0, v0, np.zeros(3), B1) r2, v2 = simulate_motion(r0, v0, E2, B1) r3, v3 = simulate_motion(r0, v0, E3, B1) # Calculate Larmor radius for case 1 (should be roughly constant) larmor_radius_1 = calculate_larmor_radius(v1[-1], B1) # Calculate drift velocity for crossed fields case drift_velocity = calculate_drift_velocity(E3, B1) print(f\"Larmor radius (final) in uniform B: {larmor_radius_1:.3e} meters\") print(f\"E x B drift velocity in crossed fields: {drift_velocity} m/s\") # Plotting 3D interactive plot for crossed fields case using Plotly fig = go.Figure(data=[go.Scatter3d( x=r3[:,0], y=r3[:,1], z=r3[:,2], mode='lines', line=dict(color='royalblue', width=2) )]) fig.update_layout( title='3D Particle Trajectory in Crossed Electric and Magnetic Fields', scene=dict( xaxis_title='x (m)', yaxis_title='y (m)', zaxis_title='z (m)' ), height=700, width=900 ) fig.show() # Additional Matplotlib plot showing Larmor radius and drift vector overlay plt.figure(figsize=(8,6)) plt.plot(r3[:,0], r3[:,1], label='Trajectory (XY projection)') plt.scatter(r3[-1,0], r3[-1,1], color='red', label='Final position') plt.quiver(0, 0, drift_velocity[0]*1e-6, drift_velocity[1]*1e-6, angles='xy', scale_units='xy', scale=1, color='green', label='E x B drift (scaled)') circle = plt.Circle((r3[-1,0], r3[-1,1]), larmor_radius_1, color='orange', fill=False, label='Larmor radius') plt.gca().add_artist(circle) plt.title('XY Projection with Larmor Radius and E\u00d7B Drift') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"Python Code Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#detailed-explanation-of-the-code","text":"Runge-Kutta 4th order (RK4): More accurate numerical integration method to solve the coupled differential equations of motion. Larmor Radius Calculation: Computes the radius of gyration to understand the tightness of the particle\u2019s spiral. Drift Velocity Calculation: Quantifies the average velocity perpendicular to both fields. Interactive 3D Plot: Using Plotly to allow zooming, rotating, and exploring the trajectory from all angles. Matplotlib Plot: Overlays Larmor radius and drift velocity vector for intuitive understanding of particle behavior in crossed fields.","title":"Detailed Explanation of the Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#physical-interpretation-of-outputs","text":"The Larmor radius you see indicates the radius of the spiral path of the particle in the uniform magnetic field. The \\(\\mathbf{E} \\times \\mathbf{B}\\) drift velocity vector indicates the net drift of the particle's guiding center perpendicular to both fields. The trajectory in crossed fields is complex, combining gyration and drift \u2014 important in plasma devices and astrophysics.","title":"Physical Interpretation of Outputs"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#suggestions-for-further-extensions","text":"Relativistic Corrections: Modify equations for particles nearing the speed of light. Non-uniform Fields: Add spatial dependence to fields to simulate magnetic mirrors or traps. Collisions: Include effects of particle collisions and scattering. Multiple Particles: Study collective plasma behavior. Animations: Animate the particle trajectory with velocity vectors and field lines for teaching.","title":"Suggestions for Further Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory 1. Introduction and Background Electrical circuits can often be simplified by combining resistors in series and parallel. When circuits become complex with multiple loops and junctions, manual simplification becomes tedious and error-prone. Representing the circuit as a graph helps us automate this process. Nodes (Vertices): Represent connection points (junctions) in the circuit. Edges: Represent resistors between nodes, weighted by their resistance value. 2. How to Identify Series and Parallel in a Graph? Parallel Edges When multiple edges connect the same pair of nodes, they represent resistors in parallel . Their equivalent resistance \\(R_{eq}\\) is calculated as: \\[ \\frac{1}{R_{eq}} = \\sum_{i=1}^{n} \\frac{1}{R_i} \\] Series Edges If a node (except start/end terminals) connects exactly two edges , these two resistors are in series . Node degree = 2 means exactly two neighbors. Equivalent resistance of series resistors is the sum: \\[ R_{eq} = R_1 + R_2 \\] After combining, the node is removed, and the two edges are replaced by a single edge. Nested and Complex Configurations Circuits often have series inside parallel or vice versa. The algorithm repeatedly detects and reduces series and parallel edges until the entire graph is reduced to one edge between the two terminals. 3. Detailed Algorithm Steps Input: A weighted undirected graph \\(G\\) representing the circuit. Two special nodes, start and end . Loop until only one edge between start and end remains: a. Simplify Parallel Edges: Find all edges connecting the same node pairs. Compute their parallel equivalent resistance. Replace them with a single edge. b. Simplify Series Edges: Find nodes (excluding start/end) with degree 2. Combine the two edges connected to that node in series. Remove that node. If an edge already exists between the two neighbors, combine with it in parallel. Return the resistance of the remaining edge. 4. Why this Approach? Systematic and automatable: Perfect for coding. Handles arbitrary graphs: Works for any circuit configuration. Visualizable: You can plot each step, showing the simplifications. 5. Python Code Implementation The code below: Uses networkx to represent the circuit graph. Detects and simplifies series and parallel edges iteratively. Uses matplotlib to plot the graph after each simplification step. Runs in Google Colab with inline plots. Installation (for Google Colab) !pip install networkx matplotlib Code import networkx as nx import matplotlib.pyplot as plt def plot_circuit(G, title=\"Circuit Graph\", node_pos=None): plt.figure(figsize=(8,6)) if not node_pos: node_pos = nx.spring_layout(G, seed=42) edge_labels = {(u, v): f\"{d['resistance']:.2f}\u03a9\" for u, v, d in G.edges(data=True)} nx.draw(G, pos=node_pos, with_labels=True, node_size=700, node_color='lightblue') nx.draw_networkx_edge_labels(G, pos=node_pos, edge_labels=edge_labels, font_color='red') plt.title(title) plt.show() return node_pos def simplify_parallel(G): \"\"\" Simplify all parallel edges by merging multiple edges between same nodes. \"\"\" removed_any = False # NetworkX MultiGraph allows multiple edges; convert to simple Graph for parallel detection # We'll create a new graph with combined edges # Collect edges by node pairs edge_dict = {} for u, v, data in G.edges(data=True): key = tuple(sorted([u,v])) edge_dict.setdefault(key, []).append(data['resistance']) # Rebuild graph with parallel edges merged newG = nx.Graph() newG.add_nodes_from(G.nodes()) for (u,v), resistances in edge_dict.items(): if len(resistances) > 1: # Calculate equivalent parallel resistance inv_sum = sum(1/r for r in resistances) Req = 1/inv_sum if inv_sum != 0 else float('inf') removed_any = True newG.add_edge(u,v, resistance=Req) else: newG.add_edge(u,v, resistance=resistances[0]) return newG, removed_any def simplify_series(G, start, end): \"\"\" Simplify nodes of degree 2 that are not start or end nodes (series resistors). \"\"\" removed_any = False nodes_to_remove = [] for node in list(G.nodes): if node == start or node == end: continue if G.degree[node] == 2: neighbors = list(G.neighbors(node)) u, w = neighbors[0], neighbors[1] R1 = G.edges[u, node]['resistance'] R2 = G.edges[node, w]['resistance'] Req = R1 + R2 # Remove node and its edges G.remove_node(node) # If edge u-w exists, combine in parallel if G.has_edge(u, w): R_existing = G.edges[u, w]['resistance'] inv_sum = 1/Req + 1/R_existing Req_parallel = 1/inv_sum G.edges[u, w]['resistance'] = Req_parallel else: G.add_edge(u, w, resistance=Req) removed_any = True # Node removed, so continue iteration break return G, removed_any def equivalent_resistance(G, start, end): \"\"\" Iteratively simplify the graph until only one edge remains between start and end. \"\"\" iteration = 0 pos = None # for consistent plotting positions while True: iteration += 1 print(f\"Iteration {iteration}:\") plot_title = f\"Iteration {iteration} - Before Simplification\" pos = plot_circuit(G, plot_title, node_pos=pos) # Simplify parallel edges G, changed_parallel = simplify_parallel(G) if changed_parallel: plot_circuit(G, f\"Iteration {iteration} - After Parallel Simplification\", node_pos=pos) # Simplify series edges G, changed_series = simplify_series(G, start, end) if changed_series: plot_circuit(G, f\"Iteration {iteration} - After Series Simplification\", node_pos=pos) # Check if reduced to single edge between start and end if G.number_of_edges() == 1 and G.has_edge(start, end): print(\"Circuit reduced to single equivalent resistor.\") break # If no changes, stop to prevent infinite loop if not changed_parallel and not changed_series: print(\"No further simplifications possible.\") break Req_final = G.edges[start, end]['resistance'] if G.has_edge(start, end) else None print(f\"Equivalent Resistance between {start} and {end}: {Req_final:.4f} \u03a9\") return Req_final # Example circuit setup def example_circuit(): G = nx.Graph() # Add nodes G.add_nodes_from(['A', 'B', 'C', 'D']) # Add edges with resistances (Ohms) # Example: A-B (5\u03a9), B-C (10\u03a9), A-C (20\u03a9), C-D (15\u03a9) G.add_edge('A', 'B', resistance=5) G.add_edge('B', 'C', resistance=10) G.add_edge('A', 'C', resistance=20) G.add_edge('C', 'D', resistance=15) return G # Run in Google Colab if __name__ == \"__main__\": circuit_graph = example_circuit() start_node = 'A' end_node = 'D' equivalent_resistance(circuit_graph, start_node, end_node) 6. How to Use This in Google Colab? Copy and paste the code into a notebook cell. Run the cell to install dependencies if necessary. Run the code \u2014 it will plot the circuit graph and its simplifications step-by-step. It prints the final equivalent resistance. 7. Explanation of the Example Circuit Nodes: A, B, C, D. Edges/resistors: A-B = 5 \u03a9 B-C = 10 \u03a9 A-C = 20 \u03a9 (parallel to series of A-B-C) C-D = 15 \u03a9 (series with the combined network between A and C) Stepwise simplification will: First combine A-B and B-C (series 5 + 10 = 15 \u03a9), Then combine parallel edges between A-C (20 \u03a9) and combined (15 \u03a9), Finally add series C-D (15 \u03a9). The code plots each step and prints final equivalent resistance between A and D. 8. Additional Notes The current implementation assumes simple graphs (no multiple edges at the same time). It detects parallel edges by grouping edges between same nodes. You can customize the circuit by adding/removing nodes or edges with different resistances. For very complex circuits, the algorithm still works as long as it can detect series and parallel resistors.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-introduction-and-background","text":"Electrical circuits can often be simplified by combining resistors in series and parallel. When circuits become complex with multiple loops and junctions, manual simplification becomes tedious and error-prone. Representing the circuit as a graph helps us automate this process. Nodes (Vertices): Represent connection points (junctions) in the circuit. Edges: Represent resistors between nodes, weighted by their resistance value.","title":"1. Introduction and Background"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-how-to-identify-series-and-parallel-in-a-graph","text":"","title":"2. How to Identify Series and Parallel in a Graph?"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-edges","text":"When multiple edges connect the same pair of nodes, they represent resistors in parallel . Their equivalent resistance \\(R_{eq}\\) is calculated as: \\[ \\frac{1}{R_{eq}} = \\sum_{i=1}^{n} \\frac{1}{R_i} \\]","title":"Parallel Edges"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-edges","text":"If a node (except start/end terminals) connects exactly two edges , these two resistors are in series . Node degree = 2 means exactly two neighbors. Equivalent resistance of series resistors is the sum: \\[ R_{eq} = R_1 + R_2 \\] After combining, the node is removed, and the two edges are replaced by a single edge.","title":"Series Edges"},{"location":"1%20Physics/5%20Circuits/Problem_1/#nested-and-complex-configurations","text":"Circuits often have series inside parallel or vice versa. The algorithm repeatedly detects and reduces series and parallel edges until the entire graph is reduced to one edge between the two terminals.","title":"Nested and Complex Configurations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-detailed-algorithm-steps","text":"Input: A weighted undirected graph \\(G\\) representing the circuit. Two special nodes, start and end . Loop until only one edge between start and end remains: a. Simplify Parallel Edges: Find all edges connecting the same node pairs. Compute their parallel equivalent resistance. Replace them with a single edge. b. Simplify Series Edges: Find nodes (excluding start/end) with degree 2. Combine the two edges connected to that node in series. Remove that node. If an edge already exists between the two neighbors, combine with it in parallel. Return the resistance of the remaining edge.","title":"3. Detailed Algorithm Steps"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-why-this-approach","text":"Systematic and automatable: Perfect for coding. Handles arbitrary graphs: Works for any circuit configuration. Visualizable: You can plot each step, showing the simplifications.","title":"4. Why this Approach?"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-python-code-implementation","text":"The code below: Uses networkx to represent the circuit graph. Detects and simplifies series and parallel edges iteratively. Uses matplotlib to plot the graph after each simplification step. Runs in Google Colab with inline plots.","title":"5. Python Code Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#installation-for-google-colab","text":"!pip install networkx matplotlib","title":"Installation (for Google Colab)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#code","text":"import networkx as nx import matplotlib.pyplot as plt def plot_circuit(G, title=\"Circuit Graph\", node_pos=None): plt.figure(figsize=(8,6)) if not node_pos: node_pos = nx.spring_layout(G, seed=42) edge_labels = {(u, v): f\"{d['resistance']:.2f}\u03a9\" for u, v, d in G.edges(data=True)} nx.draw(G, pos=node_pos, with_labels=True, node_size=700, node_color='lightblue') nx.draw_networkx_edge_labels(G, pos=node_pos, edge_labels=edge_labels, font_color='red') plt.title(title) plt.show() return node_pos def simplify_parallel(G): \"\"\" Simplify all parallel edges by merging multiple edges between same nodes. \"\"\" removed_any = False # NetworkX MultiGraph allows multiple edges; convert to simple Graph for parallel detection # We'll create a new graph with combined edges # Collect edges by node pairs edge_dict = {} for u, v, data in G.edges(data=True): key = tuple(sorted([u,v])) edge_dict.setdefault(key, []).append(data['resistance']) # Rebuild graph with parallel edges merged newG = nx.Graph() newG.add_nodes_from(G.nodes()) for (u,v), resistances in edge_dict.items(): if len(resistances) > 1: # Calculate equivalent parallel resistance inv_sum = sum(1/r for r in resistances) Req = 1/inv_sum if inv_sum != 0 else float('inf') removed_any = True newG.add_edge(u,v, resistance=Req) else: newG.add_edge(u,v, resistance=resistances[0]) return newG, removed_any def simplify_series(G, start, end): \"\"\" Simplify nodes of degree 2 that are not start or end nodes (series resistors). \"\"\" removed_any = False nodes_to_remove = [] for node in list(G.nodes): if node == start or node == end: continue if G.degree[node] == 2: neighbors = list(G.neighbors(node)) u, w = neighbors[0], neighbors[1] R1 = G.edges[u, node]['resistance'] R2 = G.edges[node, w]['resistance'] Req = R1 + R2 # Remove node and its edges G.remove_node(node) # If edge u-w exists, combine in parallel if G.has_edge(u, w): R_existing = G.edges[u, w]['resistance'] inv_sum = 1/Req + 1/R_existing Req_parallel = 1/inv_sum G.edges[u, w]['resistance'] = Req_parallel else: G.add_edge(u, w, resistance=Req) removed_any = True # Node removed, so continue iteration break return G, removed_any def equivalent_resistance(G, start, end): \"\"\" Iteratively simplify the graph until only one edge remains between start and end. \"\"\" iteration = 0 pos = None # for consistent plotting positions while True: iteration += 1 print(f\"Iteration {iteration}:\") plot_title = f\"Iteration {iteration} - Before Simplification\" pos = plot_circuit(G, plot_title, node_pos=pos) # Simplify parallel edges G, changed_parallel = simplify_parallel(G) if changed_parallel: plot_circuit(G, f\"Iteration {iteration} - After Parallel Simplification\", node_pos=pos) # Simplify series edges G, changed_series = simplify_series(G, start, end) if changed_series: plot_circuit(G, f\"Iteration {iteration} - After Series Simplification\", node_pos=pos) # Check if reduced to single edge between start and end if G.number_of_edges() == 1 and G.has_edge(start, end): print(\"Circuit reduced to single equivalent resistor.\") break # If no changes, stop to prevent infinite loop if not changed_parallel and not changed_series: print(\"No further simplifications possible.\") break Req_final = G.edges[start, end]['resistance'] if G.has_edge(start, end) else None print(f\"Equivalent Resistance between {start} and {end}: {Req_final:.4f} \u03a9\") return Req_final # Example circuit setup def example_circuit(): G = nx.Graph() # Add nodes G.add_nodes_from(['A', 'B', 'C', 'D']) # Add edges with resistances (Ohms) # Example: A-B (5\u03a9), B-C (10\u03a9), A-C (20\u03a9), C-D (15\u03a9) G.add_edge('A', 'B', resistance=5) G.add_edge('B', 'C', resistance=10) G.add_edge('A', 'C', resistance=20) G.add_edge('C', 'D', resistance=15) return G # Run in Google Colab if __name__ == \"__main__\": circuit_graph = example_circuit() start_node = 'A' end_node = 'D' equivalent_resistance(circuit_graph, start_node, end_node)","title":"Code"},{"location":"1%20Physics/5%20Circuits/Problem_1/#6-how-to-use-this-in-google-colab","text":"Copy and paste the code into a notebook cell. Run the cell to install dependencies if necessary. Run the code \u2014 it will plot the circuit graph and its simplifications step-by-step. It prints the final equivalent resistance.","title":"6. How to Use This in Google Colab?"},{"location":"1%20Physics/5%20Circuits/Problem_1/#7-explanation-of-the-example-circuit","text":"Nodes: A, B, C, D. Edges/resistors: A-B = 5 \u03a9 B-C = 10 \u03a9 A-C = 20 \u03a9 (parallel to series of A-B-C) C-D = 15 \u03a9 (series with the combined network between A and C) Stepwise simplification will: First combine A-B and B-C (series 5 + 10 = 15 \u03a9), Then combine parallel edges between A-C (20 \u03a9) and combined (15 \u03a9), Finally add series C-D (15 \u03a9). The code plots each step and prints final equivalent resistance between A and D.","title":"7. Explanation of the Example Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#8-additional-notes","text":"The current implementation assumes simple graphs (no multiple edges at the same time). It detects parallel edges by grouping edges between same nodes. You can customize the circuit by adding/removing nodes or edges with different resistances. For very complex circuits, the algorithm still works as long as it can detect series and parallel resistors.","title":"8. Additional Notes"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem through Simulations Motivation The Central Limit Theorem (CLT) is one of the most important results in probability theory and statistics. It states that the sampling distribution of the sample mean will tend to approximate a normal distribution as the sample size increases, regardless of the shape of the population's original distribution (as long as the variance is finite). This theorem is foundational because it justifies the widespread use of the normal distribution in inferential statistics. It underlies the logic of confidence intervals, hypothesis testing, and many machine learning models. Simulations offer a compelling, visual, and intuitive way to understand how and why the CLT holds. By conducting repeated sampling from different population types, we can observe the formation of the bell-shaped curve in action. Task Breakdown 1. Simulating Sampling Distributions We begin with generating three types of population distributions: Uniform Distribution : All values within a given interval are equally likely. For example, values between 0 and 1. Exponential Distribution : Characterized by a strong right-skew, it models time between events in a Poisson process. Binomial Distribution : Represents discrete outcomes from a fixed number of Bernoulli trials with a given probability of success. For each distribution type: Create a population dataset with a large number of elements (e.g., 100,000 samples) using random number generators. This population dataset will be used to draw multiple random samples of various sizes. 2. Sampling and Visualization We simulate the sampling process as follows: Choose a set of sample sizes: \\(n = 5, 10, 30, 50, 100\\) . For each sample size, draw a large number (e.g., 1000) of random samples from the population. Compute the sample mean of each sample. Store all sample means and plot them using histograms. Through these histograms, we can visually analyze: How the shape of the sampling distribution evolves. The rate at which normality is approached as sample size increases. How original population characteristics influence the convergence. We also recommend using KDE plots (kernel density estimators) to better visualize the smooth approximation of the sampling distribution. 3. Parameter Exploration To deepen our understanding of the CLT, we vary key parameters: A. Sample Size Larger sample sizes generally yield a sampling distribution of the mean that is more closely approximated by a normal distribution. This can be clearly observed even when the underlying population is skewed (e.g., exponential). B. Population Distribution Shape Different shapes converge at different rates: Normal: already satisfies conditions of CLT, fast convergence. Uniform: moderate convergence speed. Exponential: slow convergence due to heavy skew. C. Population Variance Variance plays a crucial role: Higher variance in the population results in wider sampling distributions . Variance of the sampling distribution decreases with increasing sample size, as per: \\(\\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n}\\) This means that as sample size increases, the sample mean becomes a more precise estimator of the population mean. 4. Practical Applications of the CLT The Central Limit Theorem has a wide range of practical uses, including: Estimating population parameters : With the CLT, we can make probabilistic statements about population parameters using only sample data. Quality control : Used to monitor and control manufacturing processes. For example, checking if the average weight of produced items deviates from a standard. Polling and Surveys : Helps to justify inference from small, random samples to the broader population. Finance : Used in risk modeling and portfolio theory to approximate the distribution of returns. Health and Medicine : Clinical trials often rely on the CLT for interpreting mean treatment effects. Machine Learning : Many statistical learning algorithms assume or rely on properties of the normal distribution. Deliverables A well-documented Markdown report and accompanying Python script or Jupyter notebook that includes: Simulated population generation for each distribution. Sample mean extraction and visualization through histograms and KDEs. Detailed observations on the emergence of normality in sampling distributions. Theoretical interpretation and relevance to the Central Limit Theorem. Hints and Resources Use NumPy for creating population and sample arrays: np.random.uniform , np.random.exponential , np.random.binomial . Use Matplotlib and Seaborn for plotting. Overlay normal curves for comparison using scipy.stats.norm.pdf . Start small: first run simulations with the uniform distribution before attempting more complex or skewed distributions. Encourage experimentation by modifying the number of samples, sample sizes, and population parameters. Conclusion This simulation-based exploration of the Central Limit Theorem provides concrete, visual evidence of a critical concept in statistics. Whether dealing with continuous or discrete data, symmetric or skewed distributions, the average of repeated samples behaves predictably. The CLT not only empowers us to make inference from samples but also forms the mathematical justification for many statistical tools and methodologies.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is one of the most important results in probability theory and statistics. It states that the sampling distribution of the sample mean will tend to approximate a normal distribution as the sample size increases, regardless of the shape of the population's original distribution (as long as the variance is finite). This theorem is foundational because it justifies the widespread use of the normal distribution in inferential statistics. It underlies the logic of confidence intervals, hypothesis testing, and many machine learning models. Simulations offer a compelling, visual, and intuitive way to understand how and why the CLT holds. By conducting repeated sampling from different population types, we can observe the formation of the bell-shaped curve in action.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-breakdown","text":"","title":"Task Breakdown"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"We begin with generating three types of population distributions: Uniform Distribution : All values within a given interval are equally likely. For example, values between 0 and 1. Exponential Distribution : Characterized by a strong right-skew, it models time between events in a Poisson process. Binomial Distribution : Represents discrete outcomes from a fixed number of Bernoulli trials with a given probability of success. For each distribution type: Create a population dataset with a large number of elements (e.g., 100,000 samples) using random number generators. This population dataset will be used to draw multiple random samples of various sizes.","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"We simulate the sampling process as follows: Choose a set of sample sizes: \\(n = 5, 10, 30, 50, 100\\) . For each sample size, draw a large number (e.g., 1000) of random samples from the population. Compute the sample mean of each sample. Store all sample means and plot them using histograms. Through these histograms, we can visually analyze: How the shape of the sampling distribution evolves. The rate at which normality is approached as sample size increases. How original population characteristics influence the convergence. We also recommend using KDE plots (kernel density estimators) to better visualize the smooth approximation of the sampling distribution.","title":"2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"To deepen our understanding of the CLT, we vary key parameters:","title":"3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#a-sample-size","text":"Larger sample sizes generally yield a sampling distribution of the mean that is more closely approximated by a normal distribution. This can be clearly observed even when the underlying population is skewed (e.g., exponential).","title":"A. Sample Size"},{"location":"1%20Physics/6%20Statistics/Problem_1/#b-population-distribution-shape","text":"Different shapes converge at different rates: Normal: already satisfies conditions of CLT, fast convergence. Uniform: moderate convergence speed. Exponential: slow convergence due to heavy skew.","title":"B. Population Distribution Shape"},{"location":"1%20Physics/6%20Statistics/Problem_1/#c-population-variance","text":"Variance plays a crucial role: Higher variance in the population results in wider sampling distributions . Variance of the sampling distribution decreases with increasing sample size, as per: \\(\\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n}\\) This means that as sample size increases, the sample mean becomes a more precise estimator of the population mean.","title":"C. Population Variance"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications-of-the-clt","text":"The Central Limit Theorem has a wide range of practical uses, including: Estimating population parameters : With the CLT, we can make probabilistic statements about population parameters using only sample data. Quality control : Used to monitor and control manufacturing processes. For example, checking if the average weight of produced items deviates from a standard. Polling and Surveys : Helps to justify inference from small, random samples to the broader population. Finance : Used in risk modeling and portfolio theory to approximate the distribution of returns. Health and Medicine : Clinical trials often rely on the CLT for interpreting mean treatment effects. Machine Learning : Many statistical learning algorithms assume or rely on properties of the normal distribution.","title":"4. Practical Applications of the CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#deliverables","text":"A well-documented Markdown report and accompanying Python script or Jupyter notebook that includes: Simulated population generation for each distribution. Sample mean extraction and visualization through histograms and KDEs. Detailed observations on the emergence of normality in sampling distributions. Theoretical interpretation and relevance to the Central Limit Theorem.","title":"Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_1/#hints-and-resources","text":"Use NumPy for creating population and sample arrays: np.random.uniform , np.random.exponential , np.random.binomial . Use Matplotlib and Seaborn for plotting. Overlay normal curves for comparison using scipy.stats.norm.pdf . Start small: first run simulations with the uniform distribution before attempting more complex or skewed distributions. Encourage experimentation by modifying the number of samples, sample sizes, and population parameters.","title":"Hints and Resources"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"This simulation-based exploration of the Central Limit Theorem provides concrete, visual evidence of a critical concept in statistics. Whether dealing with continuous or discrete data, symmetric or skewed distributions, the average of repeated samples behaves predictably. The CLT not only empowers us to make inference from samples but also forms the mathematical justification for many statistical tools and methodologies.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}